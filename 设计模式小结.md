# 设计模式小结

## 起源

模式(Pattern)起源于建筑业，根据不同环境总结设计规律。

> 模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案
>
> A pattern is a successful or efficient solution to a recurring problem within a context.

## 定义

设计模式(Design Pattern)是一套被反复使用,多数人知晓的,经过分类编目的,代码设计经验的总结,使用设计模式为了可重用代码,让代码更容易被他人理解并且提高代码的可靠性.

> 设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定制的解决方案,该方案描述了对象和类之间的相互作用.
>
> Design patterns are descriptions of communication objects and class that are customized to solve a general design problem in a particular context.

### 面向对象设计原则

SOLIDC

 六原则一法则

| 设计原则                                                 | 定义                                                         |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| 单一职责原则<br />(Single Responsibility Principlem,SRP) | 一个对象应该只包含单一的职责,并且该职责被完整的封装在一个类中.一个对象/类的设计不应太过庞大/复杂 |
| 开闭原则<br />(Open-closed Principle,OCP)                | 软件实体应当对扩展开放,对修改关闭.                           |
| 里氏代换原则<br />(Liskov Substitution Principle,LSP)    | 所有引用基类的地方必须能透明地使用其子类的对象.              |
| 接口隔离原则<br />(Interface Segregation Principle,ISP)  | 客户端不应该依赖那些它不需要的接口                           |
| 依赖倒转原则<br />(Dependence Inversion Principle,DIP)   | 高层模块不应该依赖底层魔魁啊,他们都应该依赖抽象.抽象不应该依赖细节,细节应该依赖抽象.<br />面向接口编程 |
| 合成复用原则<br />(Composite Reuse Principle,CRP)        | 优先使用对象组合,而不是通过集成达到复用                      |
| 迪米特法则<br />(Law of Demeter,LoD)                     | 每一个软件单位对其他单位都只有最小的知识,而且局限于那些单位与本单位密切相关的软件单位.<br />高内聚/低耦合 |



## 详解

**GoF三大类23种设计模式小结**

1. 创建型:对象创建
2. 结构型:对象组合
3. 行为型:对象交互

| 范围/目的 | 创建型模式                                               | 结构型模式                                                   | 行为型模式                                                   |
| --------- | -------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 类模式    | 工厂方法模式                                             | (类)适配器模式                                               | 解释器模式<br />模板方法模式                                 |
| 对象模式  | 抽象工厂模式<br />建造者模式<br />原型模式<br />单例模式 | (对象)适配器模式<br />桥接模式<br />组合模式<br />装饰模式<br />外观模式<br />享元模式<br />代理模式 | 职责链模式<br />命令模式<br />迭代器模式<br />中介者模式<br />备忘录模式<br />观察者模式<br />状态模式<br />策略模式<br />访问者模式 |

### 简要说明

| 模式类别                              | 模式名称                                          | 说明                                                         |
| ------------------------------------- | ------------------------------------------------- | ------------------------------------------------------------ |
| 创建型模式<br />(Creational Patterns) | 工厂方法模式<br />(Factory Method)                | 定义一个用于创建对象的接口,但是让子类决定将哪一个类实例化,工厂方法模式让一个类的实例化延迟到其子类.<br />一个工厂生成单一产品 |
|                                       | 抽象工厂模式<br />(Abstract Factory Pattern)      | 提供一个创建一系列相关或相互依赖对象的接口,而无须指定他们具体的类.<br />一个工厂生成多种类实例化对象 |
|                                       | 建造者模式(Builder Pattern)                       | 对一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.<br />返回对象实例设置来构建特定对象,避免大量参数导致构造方法膨胀 |
|                                       | 原型模式<br />(Prototype Pattern)                 | 使用原型实例指定特定待创建对象的类型,通过复制原型创建对象.clone的具体实现,浅克隆和深克隆<br />浅克隆是引用(基本数据类型就是复制一份,对象就是一个引用)<br />深克隆是完整的复制,不是单纯的引用 |
|                                       | 单例模式(Singleton Pattern)                       | 确保一个类只有一个实例,并提供一个全局访问点来访问这个唯一实例.<br />将构造函数私有化不让外部通过构造函数获取对象实例<br />单例模式包括懒汉与饿汉两种实现<br />饿汉实现简单但浪费资源,通过static final实现<br />懒汉实现通过延迟对象初始化来节省空间,但实现复杂,如需考虑多线程环境下的单例模式懒汉实现需通过双重验证+锁控制多线程的唯一单例 |
| 结构型模式<br />(Structural Pattern)  | 适配器模式<br />(Adapter Pattern)                 | 将一个类的接口转换成客户希望的另一个接口.适配器模式让那些接口不兼容的类可以一起工作.<br />复用旧有代码,屏蔽接口名称的不同,旧有代码与新的代码之间抽出一层adapter来屏蔽底层的差异细节 |
|                                       | 桥接模式<br />(Bridge Pattern)                    | 将抽象部分与它的实现部分解耦,使得两者能够独立自助变化.<br />不同维度的独立扩展<br />适配器模式的扩展,适配模式种adapter使用具体的旧有对象引用,而桥接模式种引用上层抽象而非具体类.借此实现双重扩展 |
|                                       | 组合模式<br />(Composite Pattern)                 | 组合多个对象形成树形结构以表示具有部分-整体关系的层次接口.组合模式让客户端可统一对待单个对象和组合对象<br />通过容器容纳不同接口/抽象类的实现,使用父级对象收容不同底层实现,遍历容器采取某一共同方法,那么方法的具体实现就衍生到了具体子类上,与适配器的组合完全不同,之前是单个对象的组合,到了组合模式就变为对象列表的组合 |
|                                       | 装饰模式<br />(Decorator Pattern)                 | 动态地给一个对象增加一些额外的职责.就是扩展功能而言,装饰模式提供了一种比使用子类更加灵活的替代方案.<br />与一般的组合(适配器)不同,适配器直接使用具体类adapter来组合而组合模式使用接口/抽象类来接具体组件的抽象component,同时继承于component保证具体的实现接口与component实现类的接口一致,并在调用基础component具体实现对象的接口后可扩展自己需要的额外操作 |
|                                       | 外观模式<br />(Facade Pattern)                    | 为子系统中的一组接口提供一个统一的入口.外观模式定义了一个高层接口,这个接口使得这一子系统更加容易使用.<br />实质还是组合之前组合一个,这次与组合模式类似,但组合模式通过特定容器来接收不同类,外观则对每个类都指定一个对象接收. |
|                                       | 享元模式<br />(Flyweight Pattern)                 | 运用共享技术有效地支持大量细粒度对象的复用.<br />对象的复用,通过容器缓存对象实例,如果以有实例直接返回实例,否则就初始化再返回,同时可自定义放入缓存容器的对象类型. |
|                                       | 代理模式<br />(Proxy Pattern)                     | 给某一个对象提供一个代理或占位符,并由代理对象来控制对原对象的访问.<br />与适配器模式不同,不会改变接口名称,与装饰模式类似,实现同样一个接口维护一个对象指向真正的实现类对象,在实现的前后添加其他操作<br />不同的是装饰模式是抽象对象内涵抽象对象,而代理是具体代理蕴含抽象对象,且装饰模式是对于原方法的扩展,代理模式不仅在原方法之后扩展在之前也可定义特殊行为 |
| 行为型模式<br />(Behavioral Pattern)  | 职责链模式<br />(Chain of Responsibility Pattern) | 避免将一个请求的发送者和接收者耦合在一起,让多个对象都有机会处理请求.将接收请求的对象连接成一条链,并且沿着这条链传递请求,知道有一个对象能够处理它为止.<br />类似链式数组,将处理的对象构成链式结构将某种请求放到链路上执行,当前节点能处理则处理,不能则交给下一个节点对应的对象处理. |
|                                       | 命令模式<br />(Command Pattern)                   | 将一个请求封装为一个对象,从而可用不同的请求对客户进行参数化,对请求排队或者请求日志,以及支持可撤销的操作.<br />分割请求的发起与执行,本质是双重适配 |
|                                       | 解释器模式<br />(Interpreter Pattern)             | 给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用该表示来解释语言种的句子.<br />编译原理中对于词法\语法\语义的描述类似,通过单词的定义到语法的定义最后实现语义描述<br />表达式(终结/非终结表达)+context(上下文,定义运行环境变量,使用map容器存储) |
|                                       | 迭代器模式<br />(Iterator Pattern)                | 提供一种方法顺序访问一个聚合对象的各个元素,而又不用暴露该对象的内部表示. |
|                                       | 中介者模式<br />(Miediator Pattern)               | 定义一个对象来封装一系列对象的交互.中介者模式使各对象之间不需要显示地相互引用,从而使其耦合松散,而且用户可独立改变他们之间的交互. |
|                                       | 备忘录模式<br />(Memento Pattern)                 | 在不破坏封装的前提下捕获一个对象的内部状态,并在该对象之外保存该状态,这样可在以后将对象恢复到原先保存的状态.<br />在对象构建/使用过程中通过集成的对象存储中间状态以便恢复 |
|                                       | 观察者模式<br />(Observer Pattern)                | 定义对象之间的一种一对多的依赖关系,使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被自动更新.<br />使用容器(列表)保存观察者,**提供一个提醒方法**遍历容器让每个观察者都更新自身状态 |
|                                       | 状态模式<br />(State Pattern)                     | 允许一个对象在其内部状态改变时改变它的行为.对象看起来似乎修改了它的类.<br />一个context方法保存具体某个实现对象,通过set方法改变对象实例从而改变行为. |
|                                       | 策略模式<br />(Strategy Pattern)                  | 定义一系列算法,将每个算法封装起来,并让他们可以相互交换.策略模式让算法可以独立于使用它的客户而变化.<br />与状态模式对比的不同,非常类似都是维护基础抽象,通过set改变行为.<br />不同点在于策略模式是外部产生的变化,状态模式是内部产生的变化 |
|                                       | 模板方法模式<br />(Template Method Pattern)       | 定义一个操作中的算法框架,而将一些步骤延迟到子类中.模板方法模式使得子类可以不改变一个算法的接口即可重定义该算法的某些特定步骤.<br />通过类的多态性(从而产生的方法重写)来改变算法的某些具体实现过程 |
|                                       | 访问者模式<br />(Visitor Pattern)                 | 表示一个作用于某对象结构中的各个元素的操作.访问者模式让用户可以在不改变各元素的类的前提下定义作用域这些元素的新操作.<br />对对象参数的改变 |

 