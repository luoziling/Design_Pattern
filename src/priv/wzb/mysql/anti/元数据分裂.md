# 元数据分裂

问题，用单个字段追踪客户每年收入，随着年份增加字段不断增加。

## 目标：支持可扩展性

优化数据库结构提升查询性能及支持表的平滑扩展

## 反模式：克隆表与克隆列

查询一张表，其性能只和这张表中数据的条数相关，越少的记录，查询速度越快。错误的结论：无论做什么，我们必须让每张表存储的记录尽可能少，导致反模式两种表现形式:

- 将一张很长的表拆分成较多小的表，使用表中某一特定的数据字段来给这些拆分出来的表命名。
- 将一个列拆分成多个子列，使用别的列中的不同值给拆分出来的列命名。

为了减少每张表记录数，不得不创建一些有很多列的表，或者创建很多表。随着数量增长，越来越多的表或者列。

EAV/多态关联反模式中在某些案例将元数据标识(列名和表名)当作字符串存储。

- EAV指列转行，来实现扩展，但实际上无法利用关系数据库的各类约束、索引，非常不合适。建议将表拆为多张表，如果是父子关系也可使用外键构建父子关联表（但切换方案的前提是扩展的列是有限的）
- 多态关联指多个父表引用，方便数据整合，缺陷是数据量膨胀，可创建关联表。

在多列属性和元数据分裂模式中，将数据值存储在列名或者表名中。

- 行转列/表，解决方案是水平分片

### 不断产生的新表

数据拆到不同表，要一个规则来定义哪些数据属于哪些表。

数据入库，根据要添加的数据值选择合适的表

数据进入合适的表（元数据表）中

每个地方与字典产生多对多关系都需维护一张中间表，新表不断产生

### 管理数据完整性

对特定表增加check约束

各自的数据必须录入各自的中间表

### 同步数据

数据的跨元数据修改导致同步困难

（暂时未遇到

### 确保唯一性

数据移动可能产生主键冲突



### 跨表查询

可能需要跨表整合查询则需UNION所有扩展表组合成衍生表

如果需整合查询哪些地方使用字典/文件操作则非常麻烦

### 同步元数据

增加一个新列需同步所有表

### 管理引用完整性

要制定一个外键会由于分裂导致无法制定

### 标识元数据分裂列

列可能根据元数据分裂，可创建含有很多列的表，按照类别扩展。



## 如何识别反模式

- 那么我们需要每。。。创建一张表/列
- 数据库所支持的最大数量表/列是多少
- 发现今早程序出错，忘记记录一张新表
- 我要如何查询多张表，其内容大量重复
- 要怎样将表名作为一个变量传递？

## 合理使用反模式

手动分割表的一个合理使用场景——归档数据将历史数据从日常使用的数据中移除。

## 解决方案：分区及标准化

当一张表的数据量变得非常巨大，除了手动拆分这张表，还有更好的办法来提升查询性能。这些方法就包括了水平分区、垂直分区及使用关联表

水平分区/分片

垂直分区某列非常大就把他们拆出以免影响其他查询性能

### 解决元数据分裂

创建关联表

使用每一个项目，每一列记录一年的BUG修复数量，还不如使用多行一列来记录。

一对多关系拆出额外的表，

**别让数据繁衍元数据**