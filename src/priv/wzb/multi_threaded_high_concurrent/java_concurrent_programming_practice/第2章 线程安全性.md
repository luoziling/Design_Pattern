# 第2章 线程安全性

> 线程/锁在并发编程中的作用，类似于铆钉和工字梁在土木工程中的作用。要建筑一座兼顾的桥梁，必须正确地使用大量的铆钉和工字梁。同理，在构建稳定的并发程序时，必须正确地使用线程和锁。

- 要编写线程安全的代码其核心在于要对状态访问操作进行管理，特别是对共享（Shared）的和可变（Mutable）的状态的访问
  - 是指一些公共变量的访问
  - 共享=》变量被多线程访问
  - 可变=》生命周期内发生变化
- 非正式=》对象状态存储在状态变量（实例/静态域）中的数据
- 对象还可能依赖其他对象就像HashMap和Entry
- 多线程对同一共享变量操作=》需要协同
  - Java的主要同步机制：synchronized
  - volatile
  - explicit lick(显示锁)
  - atomic变量
- 线程安全问题的修复（破坏共享/可变/同步机制）
  - 不再线程间共享
  - 改为不可变
  - 访问状态变量使用同步
- 线程安全类的前置设计比后续改进要简单
- 面向对象对代码的限定访问更容易编写线程安全的代码
  - 可以开创公共域
- 线程安全类和线程安全程序，类似但并不相同

## 2.1 什么是线程安全性

> 在线程安全性的定义中，最核心的概念就是正确性。如果对线程安全性的定义是模糊的，那么就是因为缺乏对正确性的清洗定义。

- 线程安全-正确性
  - 类的行为+规范一致
    - 定义各种不变性条件
    - 后验条件（Postcondition）
- 验证类的正确性
  - 无法直到，但是可确幸类的代码能工作
  - 代码可信性
  - 单线程=》所见即所知（we know it when we see it）
  - **多线程访问某个类，都可做出正确的行为=》类安全**
  - **无状态对象一定是线程安全的**
    - 例如servlet锁开创的线程私有访问，变量在线程私有的栈中
    - 类似copyOnWrite机制
  - 
- 

## 2.2 原子性

- 例如在servlet中加入一个计数器

  - ```java
    long count = 1;
    count ++;
    ```

  - 非线程安全

- ++不是原子操作包含”读取-修改-写入“

- 原子性在访问计数上可容忍，但在类似生成唯一ID的场景就不可容忍

- 并发编程中，由于不恰当执行时序出现的不正确结果=》竞态条件（Race Condition）

### 2.2.1 竞态条件

- 竞态条件=》不可靠
- 典序：先检查后执行
- 竞态条件
  - 基于一种可能失效的观察结果来做出判断活执行某个计算=》先检查后执行
- 

### 2.2.2 延迟初始化中的竞态条件

- 单例懒加载中存在竞态条件
- 竞态条件并不总产生错误还要看是否处于不恰当的执行时序。

### 2.2.3 复合操作

- 线程修改时组织其他线程修改
- 懒加载/自增都是复合操作，非原子
- 可通过线程安全类来解决问题`AtomicLong`
- 状态变量变为多个，带来额外的问题
- 

### 2.3 加锁机制

- 多个状态带来的额外问题
- 即使每个`Atomic`变量都是安全的，但是多个一起使用组成的非原子操作仍然导致线程安全问题

#### 2.3.1 内置锁

- Java内置锁=》同步代码块保证原子性、可见性

  ```java
  // lock就是被锁定的对象
  synchronized(lock){
      // 同步代码块
  }
  ```

  

- 每个Java对象都可以用作一个实现同步的锁=》内置锁/监控锁

- 内置锁=》互斥锁

- synchronized可加在方法上保证线程安全，但是带来性能问题



#### 2.3.2 重入

- 线程请求被其他线程锁定的对象会阻塞
- 同一个线程多次请求同一把锁=》重入，处理方案state变量维护加锁次数需要对应的释放次数

### 2.4 用锁来保护状态

- 锁=》代码串行访问
- 通过锁构造协议实现共享状态的独占访问来确保一致性
- 复合操作带来竞态条件
- 每个对象都有一个内置锁免去显示创建所
- 每个方法都加锁带来性能/活跃性问题

### 2.5 活跃性与性能

- 缓存提升性能=》带来共享资源访问问题
- 加锁注意代码块是否会因为执行事件过长带来活跃性/性能问题