# 第3章 对象的共享

**构建线程安全类以及通过JUC类库构建并发应用程序**

错误理解

- synchronized只保证原子性
- 同时还保证 内存可见性
  - 对象的修改需要对其他线程可见

## 3.1 可见性

- 单线程读写正常可见

- 多线程由于JMM 导致的 数据隔离导致数据变更不一定马上可见

- 例子

  ```java
  public class NoVisibility {
  	private static boolean ready;
  	private static int number;
  	private static class ReaderThread extends Thread{
  		@Override
  		public void run() {
  			while (!ready){
  				Thread.yield();
  			}
  			System.out.println("number = " + number);
  		}
  	}
  	public static void main(String[] args) throws InterruptedException {
  		ReaderThread readerThread = new ReaderThread();
  		readerThread.start();
  		number = 1;
  		ready = true;
  
  	}
  }
  ```

  - 两个问题：可见性+指令重排序=》线程一直循环/得到number=0
  - 没有同步，编译器 处理器都可能 调整操作顺序
  - 多个数据线程间同步 就使用正确的同步

### 3.1.1失效数据

- 失效数据不是必先，例如上面的多个共享数据可能一个有效一个失效
- 简单的对一个int类型变量的get/set 为保证可见性+原子性两个方法都需加synchronized 否则set有get没有可能读到旧数据，数据更新的不可见性

