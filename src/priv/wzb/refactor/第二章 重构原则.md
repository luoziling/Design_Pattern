# 第二章 重构原则

> 了解重构关键原则，以及重构时需要考虑什么问题

## 2.1 何谓重构

- 名词
  - 堆软件内部结构的调整，不改变软件可观察行为的前提下提高其可理解性，降低其修改成本。
- 动词
  - 使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构
- 重构和性能优化
  - 两者都改变内部结构但出发点不同，性能优化主要为了提高性能而不是代码可读性等其他属性
  - 重构可提高代码可读性和扩展性
- 

**两顶帽子**

- 添加新功能
- 重构

## 2.2 为何重构

重构可以帮助你始终良好地控制自己的代码。是一个工具达到一下目的。

### 重构改进软件设计

没有重构，程序的设计会逐渐腐败变质。为了实现短期目的在理解全体结构之前就修改代码程序会失去自己的结构。重构很想整理代码，让所有东西回到应处的位置上。

- 为了完成同一件事，设计不良的程序需要额外的代码，即使大量代码看上去在做同一件事
  - 例如新旧替换的代码
- 代码越多，正确的更改越难，更需要全局的完整的测试来支持，否则重构就是破坏

### 重构使软件更容易理解

- 程序设计很大程度就是与计算机交谈，编码告诉计算机做什么
- 应该及时填补 “想要它做什么”和“告诉它做什么”之间的缝隙
- 核心编程模式：告诉第二位阅读你程序的人你想要干什么，你在做什么
- 查阅的东西不完整记录，总是记录核心的要点，写过的代码难以记忆，就把所要说的记录在写过的程序中
- 重构提高对程序的理解能力

### 重构帮助找到bug

- 重构深入理解代码，搞清结构+梳理问题
- 更有效的写出健壮的代码

### 重构提高编程速度

- 良好的设计是快速开发的根本

## 2.3 何时重构

- 不应该为重构而重构
- 重构是因为你想做别的什么事，重构正好可以帮助把事情做好

### 三次法则

- 第一次做某件事只管去做
- 第二次做类似的产生反感，但无论如何还可以去做
- 第三次做类似的就应该重构

### 添加功能时重构

- 重构理清之前的代码逻辑
- 之前代码设计无法提供新的特性

### 修补错误时重构

- 调试过程中运用，提高可读性
- 收到错误报告可能因为程序不够清晰的让你一眼看出bug

### 复审代码时重构

- 代码review 传播知识，理解代码
- 获得建议和实现建议获得提升
- 运用UML示意图展现设计
- 极限编程中的结对编程

## 2.4 怎么对经理说

- 质量/技术两种层面
- 进度驱动=》不告诉
- 专业人士的开发者，觉得重构更快就去重构

> 计算机科学是这样一门科学：它相信所有问题都可以通过添加一个间接层来解决
>
> ​																				---Dennis DeBruler

**间接层的价值**

- 允许逻辑共享
- 分开解释意图和实现
- 隔离变化
- 封装条件逻辑
- 间接层页可以在合适的时候被清理

## 2.5 重构的难题

重构并非银弹

### 数据库

- 数据迁移
- 在对象模型和数据库模型中间插入一个分隔层，两者各自变化
- 在模型不稳定时产生它

### 修改接口

- 对象：允许把实现和设计的接口分开
- 重构修改了已发布接口就需要同时维护新旧两个接口
- 例如Java容器类
- 除非必要不要发布接口

### 难以通过重构手法完成的设计改动

- 难以观察全局完成最完善的重构
  - 先考虑重构的情况
  - 用简单的设计去重构
- 

### 何时不该重构

- 重新编写所有代码
- 重写而非重构：现有代码不能正常运作
- 大块头软件的拆分，然后对小组件重构
- 时间问题避免重构
- 未重构的就是技术债务

## 2.6 重构与设计

- 重构与设计互补
- 预先设计是必要的但是并不一定完全正确可以用重构来完善

## 2.7 重构与性能

- 不应为了提高纯洁性和忽视性能
- 编写快速软件的诀窍：
  - 先写出可调式的软件，然后调整获取足够的速度
- 性能消耗往往发生在一小块代码需要重量级监控工具来查找和发现
- 重构可帮助性能优化
  - 重构更快速添加功能让性能优化有更多时间
  - 良好的结构更合适性能优化
- 

## 2.8 重构起源何处

- 20世纪80年代的Smalltalk
- 语义保持性重构（semantics-preserving）
- 程序分布式多线程处理

## 小结

重构可提高代码可读性，完善程序结构从而提高开发效率，新功能更容易添加，同时给性能提升提供空间，不要马上重构重构和预先设计互补，先实现后优化，重构通常要抽取中间层，但中间层尤其时效性，必要时去除，完成任务优先，**重构和代码结构调整不一定要对不懂技术的经理说**