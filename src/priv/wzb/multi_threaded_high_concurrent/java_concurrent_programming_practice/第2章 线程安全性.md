# 第2章 线程安全性

> 线程/锁在并发编程中的作用，类似于铆钉和工字梁在土木工程中的作用。要建筑一座兼顾的桥梁，必须正确地使用大量的铆钉和工字梁。同理，在构建稳定的并发程序时，必须正确地使用线程和锁。

- 要编写线程安全的代码其核心在于要对状态访问操作进行管理，特别是对共享（Shared）的和可变（Mutable）的状态的访问
  - 是指一些公共变量的访问
  - 共享=》变量被多线程访问
  - 可变=》生命周期内发生变化
- 非正式=》对象状态存储在状态变量（实例/静态域）中的数据
- 对象还可能依赖其他对象就像HashMap和Entry
- 多线程对同一共享变量操作=》需要协同
  - Java的主要同步机制：synchronized
  - volatile
  - explicit lick(显示锁)
  - atomic变量
- 线程安全问题的修复（破坏共享/可变/同步机制）
  - 不再线程间共享
  - 改为不可变
  - 访问状态变量使用同步
- 线程安全类的前置设计比后续改进要简单
- 面向对象对代码的限定访问更容易编写线程安全的代码
  - 可以开创公共域
- 线程安全类和线程安全程序，类似但并不相同

## 2.1 什么是线程安全性

> 在线程安全性的定义中，最核心的概念就是正确性。如果对线程安全性的定义是模糊的，那么就是因为缺乏对正确性的清洗定义。

- 线程安全-正确性
  - 类的行为+规范一致
    - 定义各种不变性条件
    - 后验条件（Postcondition）
- 验证类的正确性
  - 无法直到，但是可确幸类的代码能工作
  - 代码可信性
  - 单线程=》所见即所知（we know it when we see it）
  - **多线程访问某个类，都可做出正确的行为=》类安全**
  - **无状态对象一定是线程安全的**
    - 例如servlet锁开创的线程私有访问，变量在线程私有的栈中
    - 类似copyOnWrite机制
  - 
- 

## 2.2 原子性

- 例如在servlet中加入一个计数器

  - ```java
    long count = 1;
    count ++;
    ```

  - 非线程安全

- ++不是原子操作包含”读取-修改-写入“

- 原子性在访问计数上可容忍，但在类似生成唯一ID的场景就不可容忍

- 并发编程中，由于不恰当执行时序出现的不正确结果=》竞态条件（Race Condition）

### 2.2.1 竞态条件

- 竞态条件=》不可靠
- 典序：先检查后执行
- 竞态条件
  - 基于一种可能失效的观察结果来做出判断活执行某个计算=》先检查后执行
- 

### 2.2.2 延迟初始化中的竞态条件

- 单例懒加载中存在竞态条件
- 竞态条件并不总产生错误还要看是否处于不恰当的执行时序。

### 2.2.3 复合操作

- 线程修改时组织其他线程修改
- 懒加载/自增都是复合操作，非原子
- 可通过线程安全类来解决问题`AtomicLong`
- 状态变量变为多个，带来额外的问题
- 

### 2.3 加锁机制

- 多个状态带来的额外问题
- 即使每个`Atomic`变量都是安全的，但是多个一起使用组成的非原子操作仍然导致线程安全问题

#### 2.3.1 内置锁

- Java内置锁=》同步代码块保证原子性、可见性

  ```java
  // lock就是被锁定的对象
  synchronized(lock){
      // 同步代码块
  }
  ```

  

- 每个Java对象都可以用作一个实现同步的锁=》内置锁/监控锁

- 内置锁=》互斥锁

- synchronized可加在方法上保证线程安全，但是带来性能问题



#### 2.3.2 重入

- 线程请求被其他线程锁定的对象会阻塞
- 同一个线程多次请求同一把锁=》重入，处理方案state变量维护加锁次数需要对应的释放次数

## 2.4 用锁来保护状态

- 锁=》代码串行访问
- 通过锁构造协议实现共享状态的独占访问来确保一致性
- 复合操作带来竞态条件
- 每个对象都有一个内置锁免去显示创建所
- 每个方法都加锁带来性能/活跃性问题

## 2.5 活跃性与性能

- 缓存提升性能=》带来共享资源访问问题
- 加锁注意代码块是否会因为执行事件过长带来活跃性/性能问题

## 2.6 小结

- 线程安全
  - 多线程访问共享资源保证数据一致性，得到最终想要的结果
- 原子性
  - 竞态条件=》先检查后修改
  - 多线程访问数据计算出错，例如++
  - 线程访问时被其他线程修改
  - 解决方案
    - 使用JUC下的原子类
    - 单个原子类线程安全，多个原子对象的代码块仍无法保证原子性
    - Java内置锁，monitor，synchronized 可重入，内部维护state统计加锁次数
- 加锁解决线程安全问题，带来性能与活跃性问题，锁非公平竞争导致死锁、饥饿、活锁等，加锁性能更差

## 项目

- 
- 项目描述
  - 承接活动举办，记录整体流程，打通上下游业务系统数据通道，数据聚合对外提供大屏展示
  - 活动的概念
    - 活动指公司每年举办的大大小小的活动，有的有各大组织有的可能由xxx直接组织
    - 这些活动每年都会开展，本系统就是支撑活动整体流程
  - 活动的流程
    - 活动新建提交进入需求收集评估，根据创建活动时的需求信息+活动基本信息分配对应资源
    - 资源分配完毕后活动可随时开始，可以手动提前开始活动
    - 活动进行过程中涉及安全事件处理，影响风险等级
    - 活动到时间/手动结束 结束后进行活动数据统计、总结、评分、附件上传
  - 模块的划分
    - 活动管理
    - 需求管理
    - 资源分配
    - 安全事件
    - 活动总结
    - 系统管理
  - 系统分为本体、定时任务、大屏，分别对应正常流程支持，数据对接与通知模块，数据聚合提供服务
  - 架构，基础存储是MySQL，druid连接池，mybatis交互，spring boot 下的spring+spring mvc+sprind-data-redis,统一权限控制框架shiro配合redis存储登录session

### doCreateBean

- 对象实例化

  - class对象不能为非public

  - 无参使用默认构造方法创建bean

  - 实例化之前`InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation`处理用户自定义方法

  - 实例化之后执行`MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition`

  - 实例化完成后，属性填充前，若单例bean且允许循环引用将自己提前暴露以解决循环引用

    - ```java
      	synchronized (this.singletonObjects) {
       			if (!this.singletonObjects.containsKey(beanName)) {
       				this.singletonFactories.put(beanName, singletonFactory);
       				this.earlySingletonObjects.remove(beanName);
       				this.registeredSingletons.add(beanName);
       			}
       		}
      ```

    - 通过加入容器`SingletonFactories`

  - 

- 属性填充

  - 实例化后通过`InstantiationAwareBeanPostProcessors`支持字段的特殊注入
  - 判断属性注模式
    - ByName
    - ByType
    - 贪心构造
    - 自动检测（已弃用）
  - 若设置Name/Type则自动注入
  - ByName
    - 获取所有属性的name
    - 根据name
    - 根据Name判断是否在IOC容器中/是否包含beanDefinition
      - 重新调用doGetBean方法，此方法在doCreateBean的外层，`doGetBean#getSingleton`方法
      - 依次从`singletonObjects`|`earlySingletonObjects`|`singletonFactories`三级缓存中获取，由于实例化后置入singletonFactories所以解决循环引用问题
      - 
    - 

- bean初始化

  - 初始化之前 执行`BeanPostProcessor#postProcessBeforeInitialization`
  - 初始化之后 执行`BeanPostProcessor#postProcessAfterInitialization`
