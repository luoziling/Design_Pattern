package priv.wzb.leet_code.dynamic_programming.dungeon_game_174;

/**
 * @author Satsuki
 * @time 2019/12/5 22:43
 * @description:
 * 一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
 *
 * 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
 *
 * 有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。
 *
 * 为了尽快到达公主，骑士决定每次只向右或向下移动一步。
 *
 *  
 *
 * 编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。
 *
 * 例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。
 *
 * -2 (K)	-3	3
 * -5	-10	1
 * 10	30	-5 (P)
 *
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/dungeon-game
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * 动态规划
 * 需要注意的是我们与之前的最短路径不同，并不是从左上推向右下，而是从右下反推到左上，
 * 因为如果位于某一点上如果走之后的路径需要的血量已知，那么选血量小的即可，如果从当前点去向后推则会很困难
 *
 */
public class Solution1 {

    public int calculateMinimumHP(int[][] dungeon) {
        // 行列
        int row = dungeon.length;
        int col = dungeon[0].length;

        // 对于dp 我们需要进行一点扩展（在左右侧和最下侧分别扩展一列和一行）作为边界值
        int[][] dp = new int[row+1][col+1];
        // 终点所需的值
        // 如果终点的值大于0也就是说明终点这一格并不需要耗费额外的血量
        // 在到达这个点之前血量有1就够了
        // 否则的话就需要足够的血量来抵消到达这个点的扣血(要保证骑士的存活起码需要一点血
        // 也就是-dungeon[row-1][col-1] +1
        dp[row-1][col-1] = dungeon[row-1][col-1] >0 ? 1:-dungeon[row-1][col-1] +1;

        // 初始化边界值（扩充的边界更新为最大值) 扩展边界有效的防止了后续在继续游戏的过程中选择越界的问题，并且定义边界为最大值也就是选择的时候永远不会选择走向边界
        // 扩充的行
        for (int i = 0; i <= col; i++) {
            dp[row][i] = Integer.MAX_VALUE;
        }
        // 扩充的列
        for (int i = 0; i <= row; i++) {
            dp[i][col] = Integer.MAX_VALUE;
        }
        // 逆转更新
        for (int i = row-1; i >= 0; i--) {
            for (int j = col-1; j >= 0; j--) {
                // 跳过已经初始化过的最后一个点
                if (i == row -1&& j == col-1){
                    continue;
                }
                // 选择向右走或者向下走
                // 在这里的选择由于是逆推变得有意义
                // 选择接下去消耗血量较少的即可
                // 否则如果正着从左上推到右下那么dp的转换表达式就会变为从那个点走向这个点，由于后续路途的不可预测，所以前面的血量就算再多其实也无效
//                dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + dungeon[i][j];
                dp[i][j] = Math.min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j];// 由于是逆推，所以原来的加血也就变成了扣血。扣血与正推的加血一样代表着初始血量就可以更低
                // 由一个点到达ij这个点之后逆推回去发现血量小于等于0那么肯定需要提高初始血量，使得血量足够支撑走完地下城
                if (dp[i][j]<=0){
                    dp[i][j] = 1;
                }
            }
        }

        // 不是返回初始点这里的初始点由于是逆推所以由左上变为了右下，从公主处如何出来并且消耗最小的血量
        // 所以说结果就是出口的dp所代表的血量
        return dp[0][0];
    }

    public static void main(String[] args) {
        int[][] a = new int[][]{{-2,-3,3},{-5,-10,1},{10,30,-5}};
        System.out.println(new Solution1().calculateMinimumHP(a));
    }

}
