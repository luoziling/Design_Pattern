参考：

<https://juejin.im/post/5a27c6946fb9a04509096248>

二叉排序树（Binary Search Tree）

- 左子树上所有节点值均小于或等于它的根节点的值
- 右子树上所有节点值均大于或等于它的根节点的值
- 左右子树也分别为二叉排序树

缺陷：

二叉树多次插入新节点若有一定的规律会导致树不平衡它并不是平衡二叉树



红黑树（Red Black Tree)

是一种自平衡的二叉查找树

除了符合二叉查找树的基本特性之外还附加了如下特性

1. 节点是红色或黑色
2. 根节点是黑色
3. 每个叶子节点都是黑色的空节点（NIL节点）
4. 每个红色节点的两个子节点都是黑色的。（从每个叶子到根的所有路径上不能有两个连续的红色节点）
5. 从任一节点到其每个叶子的所有路径包含相同数目的黑色节点

红黑树从根节点到叶子的最长路径不会超过最短路径的两倍

插入或删除节点红黑树的规则会被打破 需要做出一些调整维持规则

调整方式有两张：变色和旋转0 旋转又分两种左旋转和右旋转

{变色，旋转{左旋，右旋}}

变色：为了重新符合红黑树的规则，把红色节点变为黑色，或把黑色节点变为红色。

变色会产生连锁反应可能需要多次变色来满足红黑树定义

左旋转：逆时针旋转红黑树的两个节点，使得父节点被自己的右子节点代替，自己成为自己的左子节点。

![1568721645582](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1568721645582.png)

图中，身为右子节点的Y代替了X的位置，X变成了自己的左子节点

b的位置是如何变动的

b小于y，所以放在y的左边，b大于x所以放于x的右边

右旋转：顺时针旋转红黑树的两个节点，使得父节点被自己的左子节点取代，而逐渐成为自己的右子节点。

![1568721971371](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1568721971371.png)

红黑树的插入和删除包含很多情况，每种情况都有不同的处理方式

红黑树应用场合:TreeMap,TreeSet java8中hashmap也用到了红黑树



知道红黑树么

一种自平衡的二叉排序树，为了解决如果按顺序线性构建的二叉排序树会使得树变为线性结构大大降低搜索查找的速度

红黑树的特性和优势

节点不是红色就是黑色

叶子节点都是黑色

红色节点的子节点都是黑色（不存在连续的两个红色节点

根节点是黑色

从任一节点到根节点会经过同样数量的黑色节点

红黑树从根节点到叶子的最长路径不会超过路径的两倍

何时旋转

当插入节点是红色节点且其父节点也是红色节点时候需要调整

调整方法有变色和旋转

旋转分为左旋和右旋

变色会产生连锁反应可能需要多次变色来满足红黑树定义

变色-左旋-变色-右旋-变色

treemap

treeset

hashmap jdk1.8

AVL树平衡规则

```java
// 当添加完一个节点后，如果右子树的高度-左子树的高度>1
        // 左旋转
// 在左旋转之前必须判定
//// 如果它（根节点）的右子树的左子树高度大于它（根节点的左子树）的右子树高度
// 需要对右子节点先进行右旋
//右旋相反
```

