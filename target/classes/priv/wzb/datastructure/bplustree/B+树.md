# B+树

树数据结构，用于数据库和操作系统的文件系统。保持数据稳定有序插入修改拥有较为稳定的对数时间复杂度

## 平衡二叉树

1. 非叶子节点最多拥有两个子节点
2. 非叶子节点值大于左边子节点小于右边子节点
3. 树的左右两边层级数相差不会大于一
4. 没有值相等重复的节点。

## B树

属于多叉树又名平衡多路查找树，数据库索引技术里大量使用着B树和B+树

规则

排序方式：所有节点关键字按递增次序排列，并遵循左小右大原则

子节点数：非叶节点的子节点数大于1且<=M且M>=2空树除外 (M=M路 M叉树)

关键字数：枝节点的关键字数量大于等于ceil(m/2)-1

所有叶子节点均在同一层



若根节点不是终端节点，则至少有两颗子树

除根节点以外的所有非叶节点至少有M/2颗子数之多有M个子树关键字数位子数-1

所有叶子节点位于同一层





**一个m阶的B树具有如下几个特征：**





1.根结点至少有两个子女。



2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m



3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m



4.所有的叶子结点都位于同一层。



5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

这个图用以表示往 4 阶 B 树中依次插入下面这组数据的过程：

6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4

![B树插入](G:\学习\pic\163a9a83c2de95ba.gif)

1. 首先明确：**4 阶 B 树表示每个节点最多有 4 个子树、3 个关键字（关键字为子树减一），最少有 2 个子树、一个关键字**
2. 添加 6，第一个节点，没什么好说的
3. 添加 10，根节点最多能放三个关键字，按顺序添到根节点中
4. 添加 4，还能放到根节点中
5. 添加 14，这时超出了关键字最大限制，需要把 14 添加为子树，同时为了保证“所有叶子节点在同一层”，就需要拆几个关键字作为子树：

![这里写图片描述](https://user-gold-cdn.xitu.io/2018/5/29/163a9a8432fdb64b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 拆为：![这里写图片描述](https://user-gold-cdn.xitu.io/2018/5/29/163a9a8433e01546?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

这个拆的过程比较复杂，首先要确定根节点保留几个关键字，由于**“非叶子节点的根节点至少有 2 棵子树”**的限制，那就至少需要两个关键字分出去，又因为**“子树数是关键字数+1”**，如果根节点有两个关键字，就得有三个子树，无法满足，所以只好把除 6 以外的三个关键字都拆为子树。

谁和谁在一个子树上呢，根据**“左子树比关键字小、右子树比关键字大”**的规律，4 在左子树，10 和 14 在右子树。

继续添加 ：

1. 添加 5，放到 4 所在的子树上
2. 添加 11，放在 10 和 14 所在的右子树上
3. 添加 15，按大小应该放到 10、11 和 14 所在的子树上，但因为超过了关键字数限制，又得拆分

![这里写图片描述](https://user-gold-cdn.xitu.io/2018/5/29/163a9a843f1656c8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

因为**“根节点必须都在同一层”**，因此我们不能给现有的左右子树添加子树，只能添加给 6 了；但是如果 6 有三个子树，就必须得有 2 个关键字，提升谁做关键字好呢，这得看谁做 6 中间的子树，因为右子树的所有关键字都得比父节点的关键字大，所以这个提升的关键字只能比未来右子树中的关键字都小，那就只有 10 和 11 可以考虑了。

提升 10 吧，没有比它小的做子树，那就只能提升 11 了：

![这里写图片描述](https://user-gold-cdn.xitu.io/2018/5/29/163a9a8449e5305e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

再添加元素也是类似的逻辑：

1. 首先考虑要插入的子树是否已经超出了关键字数的限制
2. 超出的话，如果要插入的位置是叶子节点，就只能拆一个关键字添加到要插入位置的父节点
3. 如果非叶子节点，就得从其他子树拆子树给新插入的元素做孩子

删除也是一样的，要考虑删除孩子后，父节点是否还满足子树 k 介于 M/2 和 M 的条件，不满足就得从别的节点拆子树甚至修改相关子树结构来保持平衡。

总之添加、删除的过程很复杂，要考虑的条件很多，具体实现就不细追究了，这里我们有个基本认识即可。

正是这个复杂的保持平衡操作，使得平衡后的 B 树能够发挥出磁盘中快速查找的作用。

## 使用场景

> 这部分摘自：[浅谈算法和数据结构：平衡查找树之B树](https://link.juejin.im/?target=http%3A%2F%2Fblog.jobbole.com%2F79311%2F)

文件系统和数据库系统中常用的B/B+ 树，他通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。他广泛用于文件系统及数据库中，如：

- Windows：HPFS 文件系统
- Mac：HFS，HFS+ 文件系统
- Linux：ResiserFS，XFS，Ext3FS，JFS 文件系统
- 数据库：ORACLE，MYSQL，SQLSERVER 等中
- 数据库：ORACLE，MYSQL，SQLSERVER 等中

## B+树

<https://mp.weixin.qq.com/s/jRZMMONW3QP43dsDKIV9VQ>

**一个m阶的B+树具有如下几个特征：**



1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。



2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。



3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

因为B+树最下一层叶子节点有一部分是对于父节点的重复，所以B+树的遍历查找只需要查找最后一层子节点所形成的链表即可

对于B-树的优势

1. IO次数更少
2. 查询性能稳定
3. 范围查询渐变

**B+树的特征：**



1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引（**因为父节点所表示的数据是一段范围把数据进行了分段处理提取了关键部分也就是索引**），**所有数据都保存在叶子节点**。



2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。



3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。





**B+树的优势：**



1.单一节点存储更多的元素，使得查询的IO次数更少。**IO次数少**



2.所有查询都要查找到叶子节点，查询性能稳定。**性能稳定**



3.所有叶子节点形成有序链表，便于范围查询。**形成索引范围查询**





参考：

<https://tech.meituan.com/2014/06/30/mysql-index.html>

1.通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N **对此公式进行分析 若总数据量N一定时每个盘块的数据量（B+树的每个节点存储的元素）越多那么IO次数就越少，因为是对数所以普通的查找换成B+树为数据结构的查询后IO次数以指数级别减少**当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。

2.当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。