# 1028技术分享会

| 时间   | 2020.10.28                               |
| ------ | ---------------------------------------- |
| 地点   | 4F03会议室                               |
| 参与人 |                                          |
| 内容   | JUC多线程及并发、XXL-JOB运行相关源码分析 |



## JUC多线程及并发

### volatile

轻量级线程同步机制，保证线程可见性，不保证原子性，禁止指令重排

#### 可见性

![](https://pic4.zhimg.com/80/v2-b098a84eb7598d70913444a991d1759b_720w.jpg)

可见性如何保证？设计JMM Java内存模型

JMM Java内存模型一种抽象规范，描述使用Java导致的内存变动

每个线程都有自己内部的工作内存（栈空间），主存变量共享，但每个线程操作变量都必须在自己的工作内存中操作

线程之间无法访问对方的工作内存因此信息交换都在主存中完成，线程会定期将更新的数据刷到主存/从主存拉取最新的数据，所以在多线程环境下不能保证每个线程操作的都是同一个最新值，会导致多线程的累加引发值覆盖，最终结果与预期不符

加上volatile关键字可保证线程可见每次都去内存中获取最新值

```java
package priv.wzb.multi_threaded_high_concurrent.volatile1;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * @author Satsuki
 * @time 
 * @description:
 */
public class TestVolatile {
//     int num = 0;
    volatile int num = 0;
    // 使用Atomic数据类型保证++操作的原子性
    AtomicInteger numAtom = new AtomicInteger();

    public void addTo60(){
        num = 60;
    }
    public void addPlus(){
//        synchronized (this){
//            num++;
//        }
        num++;
        numAtom.incrementAndGet();

    }

    public static void main(String[] args) {
        // 验证可见性
        TestVolatile testVolatile = new TestVolatile();

//        new Thread(()->{
//            try {
//                TimeUnit.SECONDS.sleep(2);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
//            testVolatile.addTo60();
//            System.out.println(Thread.currentThread().getName() + ":" + testVolatile.num);
//
//
//        },"AAA").start();
//
//        // 不加volatile不可见其他多线程的改动（不会主动去内存中刷新当前线程本地内存中存储的值
//        while (testVolatile.num==0){
//
//        }
//        System.out.println(Thread.currentThread().getName() + "over");

//        // 不保证原子性
        for (int i = 0; i < 20; i++) {
            new Thread(()->{
                for (int j = 0; j < 1000; j++) {
                    testVolatile.addPlus();
                }
            },String.valueOf(i)).start();
        }
        // 保证线程执行完毕
        while (Thread.activeCount()>2){
            Thread.yield();
        }
        System.out.println(testVolatile.num);
        System.out.println(Thread.currentThread().getName() + ":" + testVolatile.numAtom);
    }
}
```

但是++自身就不是原子操作，所以导致最终值还是不准确

volatile保证可见性，不保证原子性

#### JVM内存模型

Java8之前

![](https://user-gold-cdn.xitu.io/2019/10/22/16df19d81ad389b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

Java8的变更

![](https://user-gold-cdn.xitu.io/2019/10/22/16df19d8f942f7c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



#### 禁止指令重排

```java
int a = 0;
boolean flag = false;

public void write() {
   a = 1;
   flag = true;
}

public void read() {
   if (flag){
      a = a + 5;
      System.out.println(a);
   }
}
```

指令重排可能导致write中的两条指令执行顺序颠倒，多线程读写可能导致read读取的flag为false但a已经变为1

不保证原子性

### AtomicInteger

atomic_test

除了使用valatile还可通过Atomic源自类的CAS操作保证数据一致性

incrementAndGet，自增方法，内部实现使用CAS

采用自旋锁的设计思想，不断比较期望值与现有值是否一致，一致则更新否则说明有改动

CAS底层是UnSafe类这个类会直接操作内存，是依赖操作系统底层的原子性操作所以不会产生数据不一致问题



CAS开销大，只能保证共享变量的原子性，引发ABA问题（可通过版本号/时间戳来辅助解决）

XXL中 路由策略，轮询策略使用原子类进行自增，多任务多线程触发场景保证数据安全

```java
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
```

### 集合类

container_safe

List的默认实现集合类是线非线程安全的

集合类的线程不安全问题可通过Collections工具类实现，Vector是早期的线程安全实现方式大量采用synchronized导致效率极低

vector源码:

```java
/**
 * Adds the specified component to the end of this vector,
 * increasing its size by one. The capacity of this vector is
 * increased if its size becomes greater than its capacity.
 *
 * <p>This method is identical in functionality to the
 * {@link #add(Object) add(E)}
 * method (which is part of the {@link List} interface).
 *
 * @param   obj   the component to be added
 */
public synchronized void addElement(E obj) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = obj;
}
```

直接加在了方法上，synchronized通过加锁的方式来保证多线程的线程安全问题，锁的粒度应该越小越好

Collections.synchronizedList(new (线程不安全的容器类))

锁的粒度更小

map/queue之类的集合可使用Concurrent开头的集合类保证集合操作的线程安全，以ConcurrentHashMap举例内部采用synchronized来锁定代码块保证线程安全

```java
package priv.wzb.multi_threaded_high_concurrent.container_safe;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * @author Satsuki
 * @time 
 * @description: 集合类不安全问题
 */
public class ContainerNotSafeDemo {
    public static void main(String[] args) {
        // 并发出错演示
//        List<String> list = new ArrayList<>();


        // 解决方案1：Vector,这个类是加了synchronized的，线程安全
        // 但是耗时严重 public synchronized boolean add(E e) {
        // 直接在方法体上加了
//        List<String> list = new Vector<>();


        // 解决方案2：Collections.synchronizedList(new (线程不安全的容器类))
        // public void add(int index, E element) {
        //            synchronized (mutex) {list.add(index, element);}
        //        }
        // 可见，传入一共线程不安全的list，在Collections内部会自动创建一共线程安全的list
        // 这个相对于vector锁的粒度更小并没有锁定方法体，而是锁了代码块
        // 使用synchronzed
        // final Object mutex;     // Object on which to synchronize
        // mutex是线程锁定对象
        List<String> list = Collections.synchronizedList(new ArrayList<>());
//        list.add("11");


        // 解决方案3 ： CopyOnWriteArrayList
        // /** The lock protecting all mutators */
        //    final transient ReentrantLock lock = new ReentrantLock();
        //
        //    /** The array, accessed only via getArray/setArray. */
        //    private transient volatile Object[] array;
        // 使用reentrantlock可重入锁
        // 数组采用volatile修饰，阻止指令重排，保证可见性，操作原子性由lock保证
        // /**
        //     * Appends the specified element to the end of this list.
        //     *
        //     * @param e element to be appended to this list
        //     * @return {@code true} (as specified by {@link Collection#add})
        //     */
        //    public boolean add(E e) {
        //        final ReentrantLock lock = this.lock;
        //        lock.lock();
        //        try {
        //            Object[] elements = getArray();
        //            int len = elements.length;
        //            Object[] newElements = Arrays.copyOf(elements, len + 1);
        //            newElements[len] = e;
        //            setArray(newElements);
        //            return true;
        //        } finally {
        //            lock.unlock();
        //        }
        //    }
        // 可见其add方法的过程是
        // 加锁
        // 复制产生新的数组
        // 将要加入的值放入新数组
        // 将数组指向新数组
        // 解锁
//        List<String> list = new CopyOnWriteArrayList<>();



        // 多个线程写
//        for (int i = 0; i < 100; i++) {
//            new Thread(()->{
//                list.add(UUID.randomUUID().toString().substring(1,8));
//                System.out.println(list);
//            },String.valueOf(i)).start();
//        }

        // 报错 java.util.ConcurrentModificationException
        // 原因：多线程争抢修改
        // 解决方案
        // Vector/Collections.synchronized/CopyOnWrite


        // 测试set和map
        // 出错：java.util.ConcurrentModificationException
        // 解决方案与list相似
//        Set<String> set = new HashSet<>();
//        Set<String> set = Collections.synchronizedSet(new HashSet<>());
        Set<String> set = new CopyOnWriteArraySet<>();


//        for (int i = 0; i < 100; i++) {
//            new Thread(()->{
//                // subString[)
//                set.add(UUID.randomUUID().toString().substring(2,8));
//                System.out.println(set);
//            },String.valueOf(i)).start();
//        }


        // 测试map

        // 出错:java.util.ConcurrentModificationException
//        Map<String,String> map = new HashMap<>();
//        Map<String,String> map = Collections.synchronizedMap(new HashMap<>());
        Map<String,String> map = new ConcurrentHashMap<>();

        // 在ConcurrentHashMap中将可能出错的关键代码加入了synchronized进行代码块锁定
        //synchronized (f) {
        //                    if (tabAt(tab, i) == f) {
        //                        if (fh >= 0) {
        //                            binCount = 1;
        //                            for (Node<K,V> e = f;; ++binCount) {
        //                                K ek;
        //                                if (e.hash == hash &&
        //                                    ((ek = e.key) == key ||
        //                                     (ek != null && key.equals(ek)))) {
        //                                    oldVal = e.val;
        //                                    if (!onlyIfAbsent)
        //                                        e.val = value;
        //                                    break;
        //                                }
        //                                Node<K,V> pred = e;
        //                                if ((e = e.next) == null) {
        //                                    pred.next = new Node<K,V>(hash, key,
        //                                                              value, null);
        //                                    break;
        //                                }
        //                            }
        //                        }
        //                        else if (f instanceof TreeBin) {
        //                            Node<K,V> p;
        //                            binCount = 2;
        //                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
        //                                                           value)) != null) {
        //                                oldVal = p.val;
        //                                if (!onlyIfAbsent)
        //                                    p.val = value;
        //                            }
        //                        }
        //                    }
        //                }

        for (int i = 0; i < 100; i++) {
            new Thread(()->{
                map.put(UUID.randomUUID().toString().substring(2,8),UUID.randomUUID().toString().substring(2,8));
                System.out.println(map);
            },String.valueOf(i)).start();



        }


    }
}
```

### ReentrantLock

thread_reentrantlock

Java早期版本使用synchronized关键字锁定某个对象保证数据安全

现在使用ReentrantLock较多，更加灵活与方便扩展在初始化通过指定true/false指定是否是公平锁(默认非公平)

可重入锁

锁的传递性

两者都是可重入锁（避免死锁

两者比较：

- ReentrantLock可以完成synchronized的功能所以可以替代synchronized

  ```java
  package priv.wzb.multi_threaded_high_concurrent.thread_reentrantlock;
  
  import java.util.concurrent.TimeUnit;
  
  /**
   * @author Satsuki
   * @time 
   * @description:ReentrantLock可以完成synchronized的功能所以可以替代synchronized
   */
  public class ReentrantLock1 {
      synchronized void m1(){
          for(int i =0;i<10;i++){
              try {
                  TimeUnit.SECONDS.sleep(1);
              }catch (InterruptedException e){
                  e.printStackTrace();
              }
              System.out.println(i);
          }
      }
      synchronized void m2(){
          System.out.println("m2...");
      }
  
      public static void main(String[] args){
          ReentrantLock1 r1 = new ReentrantLock1();
          new Thread(r1::m1).start();
          try {
              TimeUnit.SECONDS.sleep(1);
          }catch (InterruptedException e){
              e.printStackTrace();
          }
          new Thread(r1::m2).start();
      }
  }
  ```

- ReentrantLock比synchronized灵活 可以使用tryLock尝试锁定

  * 尝试锁定不管锁定与否都将继续执行也可以根据返回值判定是否锁定
  * 可以制定tryLock的时间，由于tryLock(time)抛出异常，
  * 所以要注意unlock的操作必须放到finally中

  ```java
  package priv.wzb.multi_threaded_high_concurrent.thread_reentrantlock;
  
  import java.util.concurrent.TimeUnit;
  import java.util.concurrent.locks.Lock;
  import java.util.concurrent.locks.ReentrantLock;
  
  /**
   * @author Satsuki
   * @time 
   * @description:ReentrantLock比synchronized灵活 可以使用tryLock尝试锁定
   * 尝试锁定不管锁定与否都将继续执行也可以根据返回值判定是否锁定
   * 可以制定tryLock的时间，由于tryLock(time)抛出异常，
   * 所以要注意unlock的操作必须放到finally中
   */
  public class ReentrantLock2 {
      Lock lock = new ReentrantLock();
      void m1(){
          lock.lock();
          try {
              for(int i = 0;i< 10 ;i++){
                  TimeUnit.SECONDS.sleep(1);
                  System.out.println(i);
              }
          }catch (InterruptedException e){
              e.printStackTrace();
          }finally {
              lock.unlock();
          }
      }
  
      void m2(){
  
          boolean locked = false;
          try {
              locked = lock.tryLock(1000, TimeUnit.MILLISECONDS);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println("m2..." + locked);
          if (locked) lock.unlock();
  //        lock.lock();
  //        System.out.println("m2...");
      }
  
      public static void main(String[] args){
          ReentrantLock2 r2 = new ReentrantLock2();
          new Thread(r2::m1).start();
          new Thread(r2::m2).start();
      }
  }
  ```

- 可以通过interrupt来打断

  ```java
  package priv.wzb.multi_threaded_high_concurrent.thread_reentrantlock;
  
  
  import java.util.concurrent.TimeUnit;
  import java.util.concurrent.locks.Lock;
  import java.util.concurrent.locks.ReentrantLock;
  
  /**
   * @author Satsuki
   * @time 
   * @description:可以通过interrupt来打断
   */
  public class ReentrantLock3 {
  //    public ReentrantLock void test(){
  //        System.out.println("aaa");
  //    }
      public static void main(String[] args) {
          Lock lock = new ReentrantLock();
  
          Thread t1 = new Thread(() -> {
              try {
                  lock.lock();
                  System.out.println("t1.start");
                  TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);
              } catch (InterruptedException e) {
                  System.out.println("interrupted!");
                  e.printStackTrace();
              } finally {
                  lock.unlock();
              }
          });
          t1.start();
  
          Thread t2 = new Thread(() -> {
              try {
                  lock.lockInterruptibly();
                  System.out.println("t2 start");
                  TimeUnit.SECONDS.sleep(5);
                  System.out.println("t2 end");
              } catch (InterruptedException e) {
                  System.out.println("interrupted");
                  e.printStackTrace();
              } finally {
                  lock.unlock();
              }
  
          });
          t2.start();
  
          try {
              TimeUnit.SECONDS.sleep(1);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          t2.interrupt();//打断线程2的等待
  
      }
  }
  ```

- ReentrantLock可以指定为公平锁，synchronized是非公平锁，非公平锁可能导致线程饿死，一直得不到执行

  ```java
  package priv.wzb.multi_threaded_high_concurrent.thread_reentrantlock;
  
  import java.util.concurrent.locks.ReentrantLock;
  
  
  /**
   * @author Satsuki
   * @time 
   * @description:ReentrantLock可以指定为公平锁，
   * 公平锁就是哪个线程等待时间长就哪个线程先执行
   * ReentrantLock必须要在finally中unlock(), 否则,如果在被加锁的代码中抛出了异常,那么这个锁将会永远无法释放.
   */
  public class ReentantLock4 extends Thread {
      private static ReentrantLock lock = new ReentrantLock(true);
      public void run(){
          for(int i = 0 ;i<100;i++){
              lock.lock();
              try {
                  System.out.println(Thread.currentThread().getName() + "获得锁");
              }finally {
                  lock.unlock();
              }
          }
      }
  
      public static void main(String[] args){
          ReentantLock4 r4 = new ReentantLock4();
          Thread th1 = new Thread(r4);
          Thread th2 = new Thread(r4);
          th1.start();
          th2.start();
  
      }
  }
  ```

  





### 独占锁(写)/共享锁(读)/互斥锁

read_write_lock

写锁是排他锁代表写操作执行完成之前不能执行其他写操作

读锁是共享锁读操作完成之前允许其他操作

```java
package priv.wzb.multi_threaded_high_concurrent.read_write_lock;


import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;

// 资源类
class MyCache{
    // 这里模拟缓存所以需要加上volatile保证可见性
    private volatile Map<String,Object> map = new HashMap<>();
//    private Lock lock = new ReentrantLock();
    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();


    public void put(String key,Object value){
        rwLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t 正在写：" +key);
            // 模拟延迟，暂停线程
            try {
                TimeUnit.MILLISECONDS.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            map.put(key,value);
            System.out.println(Thread.currentThread().getName() + "\t 写入完成");
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            rwLock.writeLock().unlock();
        }
//        System.out.println(Thread.currentThread().getName() + "\t 正在写：" +key);
//        // 模拟延迟，暂停线程
//        try {
//            TimeUnit.MILLISECONDS.sleep(300);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//        map.put(key,value);
//        System.out.println(Thread.currentThread().getName() + "\t 写入完成");
    }


    public void get(String key){
        rwLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t 正在读取：" +key);
            // 模拟延迟，暂停线程
            try {
                TimeUnit.MILLISECONDS.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            Object result = map.get(key);
            System.out.println(Thread.currentThread().getName() + "\t 读取完成:" + result);
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            rwLock.readLock().unlock();
        }
//        System.out.println(Thread.currentThread().getName() + "\t 正在读取：" +key);
//        // 模拟延迟，暂停线程
//        try {
//            TimeUnit.MILLISECONDS.sleep(300);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//        Object result = map.get(key);
//        System.out.println(Thread.currentThread().getName() + "\t 读取完成:" + result);
    }

    // 缓存三大操作，读、写、清除
    public void clearMap(){
        map.clear();
    }

}

/**
 * @author Satsuki
 * @time 
 * @description:
 * 读写锁
 * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该同时进行
 * 但是
 * 如果一个线程想进去写共享资源，就不应该再有其他线程可以对该资源进行读或写
 * 小总结：
 * 读-读能共存
 * 读-写不能共存
 * 写-写不能共存
 *
 * 写操作：原子+独占，整个过程必须是一个完整的过程无法被打断
 */
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache myCache = new MyCache();
        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(()->{
                myCache.put(tempInt+"",tempInt+"");
            },String.valueOf(i)).start();
        }


        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(()->{
                myCache.get(tempInt+"");
            },String.valueOf(i)).start();
        }

    }
}
```

### CountDownLatch/CyclicBarrier/Semaphore

CountDownLatch线程的异步转同步，控制多线程下，线程顺序执行

加入CountDownLatch让异步的多线程转为同步执行

```java
package priv.wzb.multi_threaded_high_concurrent.countdown_latch;

import java.util.concurrent.CountDownLatch;

/**
 * @author Satsuki
 * @time 
 * @description:
 */
public class CountDownLatchDemo {
    public static void main(String[] args) {
        CountDownLatch countDownLatch = new CountDownLatch(6);
        for (int i = 1; i <= 6; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName() + "\t上完自习，离开教室");
                countDownLatch.countDown();
            },String.valueOf(i)).start();
        }

        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "\t   main最后离开教室，释放资源");


    }
}
```

CyclicBarrier 等到多个线程执行完毕后再继续执行

```java
package priv.wzb.multi_threaded_high_concurrent.cyclic_barrier;

import java.util.concurrent.CyclicBarrier;

/**
 * @author Satsuki
 * @time 
 * @description:
 */
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()->{
            System.out.println("召唤神龙");
        });

        for (int i = 1; i <= 7; i++) {
            final int tempInt = i;
            new Thread(()->{
                System.out.println(Thread.currentThread().getName() + "\t 收集到第" + tempInt + "龙珠");
                try {
                    cyclicBarrier.await();
                }catch (Exception e){
                    e.printStackTrace();
                }
            },String.valueOf(i)).start();
        }
    }
}
```

Semaphore 信号量 信号量的主要用户两个目的,一个是用于多个共享资源的相互排斥使用,另一个用于并发资源数的控制.

```java
package priv.wzb.multi_threaded_high_concurrent.semaphore;

import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * @author Satsuki
 * @time 
 * @description:
 */
public class SemaphoreDemo {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3);// 模拟三个停车位

        for (int i = 1; i <= 6; i++) {
            // 模拟六部汽车
            new Thread(()->{
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName()+"\t 抢到车位");
                    TimeUnit.SECONDS.sleep(3);
                    System.out.println(Thread.currentThread().getName()+"\t 3S后离开车位");
                }catch (InterruptedException e){
                    e.printStackTrace();
                }finally {
                    semaphore.release();
                }
            },String.valueOf(i)).start();

        }
    }
}
```

### 线程池

线程池可控制线程运行的数量

线程池内部使用阻塞队列保存线程要执行的任务逻辑

ThreadPoolExecutor

优点：

1. 降低每次重复创建线程带来的资源消耗
2. 提高响应速度，减去新建线程的时间
3. 提高可管理性，由线程池统一分配调度

Java固定实现的主要线程池：



- Executors.newFixedThreadPool(int)

  执行一个长期的任务,性能好很多

  主要特点如下:
  1.创建一个定长线程池,可控制线程的最大并发数,超出的线程会在队列中等待.
  2.newFixedThreadPool创建的线程池corePoolSize和MaxmumPoolSize是 相等的,它使用的的LinkedBlockingQueue

  ```java
  package priv.wzb.multi_threaded_high_concurrent.thread_pool;
  
  import java.util.concurrent.*;
  
  /**
   * @author Satsuki
   * @time 
   * @description:
   */
  public class T05_FixedThreadPool {
      public static void main(String[] args) throws InterruptedException {
          ExecutorService service = Executors.newFixedThreadPool(5);
  
          for (int i = 0; i < 6; i++) {
              service.execute(()->{
                  try {
                      TimeUnit.MILLISECONDS.sleep(500);
                  }catch (InterruptedException e){
                      e.printStackTrace();
                  }
                  System.out.println(Thread.currentThread().getName());
              });
  
          }
          System.out.println(service);
          System.out.println(service.isTerminated());
          System.out.println(service.isShutdown());
          System.out.println(service);
  
          TimeUnit.SECONDS.sleep(50);
  
          System.out.println(service.isTerminated());
          System.out.println(service.isShutdown());
          System.out.println(service);
      }
  }
  ```

- Executors.newSingleThreadExecutor()

  一个任务一个线程执行的任务场景

  主要特点如下:
  1.创建一个单线程化的线程池,它只会用唯一的工作线程来执行任务,保证所有任务都按照指定顺序执行.
  2.newSingleThreadExecutor将corePoolSize和MaxmumPoolSize都设置为1,它使用的的LinkedBlockingQueue

  ```java
  package priv.wzb.multi_threaded_high_concurrent.thread_pool;
  
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;
  
  /**
   * @author Satsuki
   * @time 
   * @description:
   */
  public class SingleThreadPool {
      public static void main(String[] args) {
          ExecutorService service = Executors.newSingleThreadExecutor();
          for (int i = 0; i < 5; i++) {
              final int j=i;
              service.execute(()->{
                  System.out.println(j+" "+ Thread.currentThread().getName());
                  // 即使出错之后也不会停止运行，会创建一个新的线程来继续执行
                  int x = 1/0;
              });
          }
      }
  }
  ```

- Executors.newCachedThreadPool()

  适用:执行很多短期异步的小程序或者负载较轻的服务器

   主要特点如下:
  1.创建一个可缓存线程池,如果线程池长度超过处理需要,可灵活回收空闲线程,若无可回收,则创建新线程.
  2.newCachedThreadPool将corePoolSize设置为0MaxmumPoolSize设置为Integer.MAX_VALUE,它使用的是SynchronousQUeue,也就是说来了任务就创建线程运行,如果线程空闲超过60秒,就销毁线程

  ```java
  package priv.wzb.multi_threaded_high_concurrent.thread_pool;
  
  import java.util.concurrent.*;
  
  /**
   * @author Satsuki
   * @time 
   * @description:
   */
  
  /**
   *创建一个根据需要创建新线程的线程池，但是
   *将重用以前构造的线程
   *可用。 这些池通常会提高性能
   *执行许多短期异步任务的程序。
   *调用{@code execute}将重用以前构建的
   *线程（如果有）。 如果没有可用的现有线程，则为新的
   *将创建线程并将其添加到池中。 有线程的
   *未使用60秒被终止并从中删除
   *缓存。 因此，一个长时间闲置的游泳池将会
   *不消耗任何资源。 请注意，池类似
   *属性但不同的细节（例如，超时参数）
   *可以使用{@link ThreadPoolExecutor}构造函数创建。
   *
   * @return新创建的线程池
   */
  public class T08_CachedPool {
      public static void main(String[] args) throws InterruptedException {
          ExecutorService service = Executors.newCachedThreadPool();
          ExecutorService service1 = new ThreadPoolExecutor(
                  1,
                  1,
                  1,
                  TimeUnit.SECONDS,
                  new LinkedBlockingQueue<>(),
                  new ThreadFactory() {
                      @Override
                      public Thread newThread(Runnable r) {
                          return new Thread(r,"threadName");
                      }
                  });
  
          System.out.println(service);
  
          for (int i = 0; i < 2; i++) {
              service.execute(()->{
                  try {
                      TimeUnit.MILLISECONDS.sleep(500);
                  }catch (InterruptedException e){
                      e.printStackTrace();
                  }
                  System.out.println(Thread.currentThread().getName());
              });
          }
          System.out.println(service);
          TimeUnit.SECONDS.sleep(8);
          System.out.println(service);
      }
  }
  ```

三种线程池的比较可以根据源码进行分析

- 单例线程池可以看到线程池中只有一个线程
- newFixedThreadPool则可以指定

实际是通过建立线程池指定固定参数实现的

推荐根据需求自动建立线程池而不适用Executors来创建现有的线程池

自建线程池参数介绍

1. corePoolSize:线程池中的常驻核心线程数

   1.在创建了线程池后,当有请求任务来之后,就会安排池中的线程去执行请求任务,近视理解为今日当值线程
   2.当线程池中的线程数目达到corePoolSize后,就会把到达的任务放入到缓存队列当中.

2. maximumPoolSize:线程池能够容纳同时执行的最大线程数,此值大于等于1

3. keepAliveTime:多余的空闲线程存活时间,当空间时间达到keepAliveTime值时,多余的线程会被销毁直到只剩下corePoolSize个线程为止

   默认情况下:
   只有当线程池中的线程数大于corePoolSize时keepAliveTime才会起作用,知道线程中的线程数不大于corepoolSIze,

4. unit:keepAliveTime的单位

5. workQueue:任务队列,被提交但尚未被执行的任务.

6. threadFactory:表示生成线程池中工作线程的线程工厂,用户创建新线程,一般用默认即可

7. handler:拒绝策略,表示当线程队列满了并且工作线程大于等于线程池的最大显示 数(maxnumPoolSize)时如何来拒绝.

6和7一般使用默认的

内置拒绝策略：

JDK内置的拒绝策略

1. AbortPolicy(默认):直接抛出RejectedException异常阻止系统正常运行
2. CallerRunPolicy:"调用者运行"一种调节机制,该策略既不会抛弃任务,也不会抛出异常,而是直接拒绝任务
3. DiscardOldestPolicy:抛弃队列中等待最久的任务,然后把当前任务加入队列中尝试再次提交
4. DiscardPolicy:直接丢弃任务,不予任何处理也不抛出异常.如果允许任务丢失,这是最好的拒绝策略

以上内置策略均实现了RejectExecutionHandler接口

线程池以XXL的作为例子讲解初始化参数

com.xxl.job.admin.core.thread.JobTriggerPoolHelper

使用线程池execute方法实现runnable接口实现运行逻辑执行远程调用



### 阻塞队列

在队列为满/空的时候阻塞添加/获取的请求

用于线程的挂起与继续执行

队列满采用CAS的方式去不断判断知道队列有位置

```java
    /**
     * Inserts the specified element at the tail of this queue, waiting
     * for space to become available if the queue is full.
     *
     * @throws InterruptedException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     */
    public void put(E e) throws InterruptedException {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == items.length)
                notFull.await();
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
```

add/remove

offer/poll

put/take

## XXL-JOB源码分析

### 触发器

![](https://img2020.cnblogs.com/i-beta/1301624/202003/1301624-20200320135904253-1168265916.png)

1. 触发器整体流程：前端点击执行一次按钮，js通过AJAX调用后端接口

   ![image-20201028192909260](1028技术分享会.assets\image-20201028192909260.png)

2. 后端通过线程池执行远程调用任务

   ![image-20201028192950371](1028技术分享会.assets\image-20201028192950371.png)

3. 根据传递过来的ExecutorBlockStrategy字段与后端ExecutorBlockStrategyEnum中的title进行匹配获取路由选择策略，并根据策略选择远程调用地址

   路由策略匹配：

   ![image-20201028193039036](1028技术分享会.assets\image-20201028193039036.png)

4. 使用Java原生的java.net包执行http调用并封装返回结果

   com/xxl/job/core/biz/client/ExecutorBizClient.java

   ```java
   @Override
   public ReturnT<String> run(TriggerParam triggerParam) {
       return XxlJobRemotingUtil.postBody(addressUrl + "run", accessToken, timeout, triggerParam, String.class);
   }
   ```

5. HTTP请求addressUrl + "run"连接调度可看到是请求了run接口，但是应该被封装了，没看到具体RPC源码

6. 执行ExecutorBizImpl的run方法，选取执行器handler进而确定唯一工作线程jobThread，将定时任务推入阻塞队列，等待读取运行

   ![image-20201028193306909](1028技术分享会.assets\image-20201028193306909.png)

7. 具体运行是JobThread的run方法调用，handler 去具体执行，

   ![image-20201028193417763](1028技术分享会.assets\image-20201028193417763.png)

8. 用到了反射+注解将方法注入容器以便在运行时发现

9. 通过配置注入容器，xxl官网也描述是开启了一个服务器接收请求，RPC框架的请求与调用

### 任务启动

![](https://img2020.cnblogs.com/i-beta/1301624/202003/1301624-20200317142704552-1647789828.png)

1. XxlJobAdminConfig作为`Component`被Spring管理，启动，读取配置类，触发定时任务初始化方法，开启子线程循环触发定时任务

   ![image-20201028193621805](1028技术分享会.assets\image-20201028193621805.png)

2. 在初始化XxlJobScheduler过程中调用开启定时任务监控的子线程JobScheduleHelper.getInstance().start();

   ![image-20201028193636082](1028技术分享会.assets\image-20201028193636082.png)

3. 每五秒从数据库读取一次数据，寻找是否有要触发的定时任务，触发完的定时任务会重写TriggerNextTime并写回数据库更新执行时间

   ![image-20201028193657484](1028技术分享会.assets\image-20201028193657484.png)

4. 在寻找触发定时任务时分为三种情况分别操作：

   任务过时：当前时间超过任务执行时间，刷新数据跳过本次执行

   任务触发：任务将在5秒内执行则直接触发并更新下次触发的时间，如果下次触发事件在5S内放入ring容器

   延迟操作：未到启动时间设定ringSecond放入容器

**ringThread的分析**

1. 选取时间，将要执行的任务放入ringData容器Map<Integer, List<Integer>> ringData
2. 选取list将jobId推入容器，队列+链表
3. 执行过程中开了一个ringThread，读取ring缓存并触发执行

```java
public void start(){

    // schedule thread
    scheduleThread = new Thread(new Runnable() {
        @Override
        public void run() {

            try {
                // 每5秒执行一次
                TimeUnit.MILLISECONDS.sleep(5000 - System.currentTimeMillis()%1000 );
            } catch (InterruptedException e) {
                if (!scheduleThreadToStop) {
                    logger.error(e.getMessage(), e);
                }
            }
            logger.info(">>>>>>>>> init xxl-job admin scheduler success.");

            // pre-read count: treadpool-size * trigger-qps (each trigger cost 50ms, qps = 1000/50 = 20)
            int preReadCount = (XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax() + XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax()) * 20;

            while (!scheduleThreadToStop) {

                // Scan Job
                // 任务开始时间
                long start = System.currentTimeMillis();

                Connection conn = null;
                Boolean connAutoCommit = null;
                PreparedStatement preparedStatement = null;

                // 是否有任务触发
                boolean preReadSuc = true;
                try {

                    conn = XxlJobAdminConfig.getAdminConfig().getDataSource().getConnection();
                    connAutoCommit = conn.getAutoCommit();
                    conn.setAutoCommit(false);

                    // 添加排他锁
                    // 锁定schedule_lock，不让其他线程访问
                    preparedStatement = conn.prepareStatement(  "select * from xxl_job_lock where lock_name = 'schedule_lock' for update" );
                    preparedStatement.execute();

                    // tx start

                    // 1、pre read
                    long nowTime = System.currentTimeMillis();
                    // 查询5S内要启动的定时任务
                    List<XxlJobInfo> scheduleList = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleJobQuery(nowTime + PRE_READ_MS, preReadCount);
                    if (scheduleList!=null && scheduleList.size()>0) {
                        // 遍历进行任务过时/触发/延迟操作
                        // 2、push time-ring
                        for (XxlJobInfo jobInfo: scheduleList) {

                            // time-ring jump
                            if (nowTime > jobInfo.getTriggerNextTime() + PRE_READ_MS) {
                                // 2.1、trigger-expire > 5s：pass && make next-trigger-time
                                // 任务执行超时则跳过，更行下次执行时间
                                logger.warn(">>>>>>>>>>> xxl-job, schedule misfire, jobId = " + jobInfo.getId());

                                // fresh next
                                refreshNextValidTime(jobInfo, new Date());

                            } else if (nowTime > jobInfo.getTriggerNextTime()) {
                                // 2.2、trigger-expire < 5s：direct-trigger && make next-trigger-time
                                // 触发过期时间在5S内，直接触发

                                // 1、trigger
                                JobTriggerPoolHelper.trigger(jobInfo.getId(), TriggerTypeEnum.CRON, -1, null, null, null);
                                logger.debug(">>>>>>>>>>> xxl-job, schedule push trigger : jobId = " + jobInfo.getId() );

                                // 2、fresh next
                                refreshNextValidTime(jobInfo, new Date());

                                // next-trigger-time in 5s, pre-read again
                                // 定时任务在五秒内又要触发放入TimeRing
                                if (jobInfo.getTriggerStatus()==1 && nowTime + PRE_READ_MS > jobInfo.getTriggerNextTime()) {

                                    // 1、make ring second
                                    int ringSecond = (int)((jobInfo.getTriggerNextTime()/1000)%60);

                                    // 2、push time ring
                                    pushTimeRing(ringSecond, jobInfo.getId());

                                    // 3、fresh next
                                    refreshNextValidTime(jobInfo, new Date(jobInfo.getTriggerNextTime()));

                                }

                            } else {
                                // 2.3、trigger-pre-read：time-ring trigger && make next-trigger-time
                                // 未到启动时间，设定ringSecond放入容器

                                // 1、make ring second
                                // 选取时间，将执行时间映射到60S内
                                int ringSecond = (int)((jobInfo.getTriggerNextTime()/1000)%60);

                                // 2、push time ring
                                // 任务推入缓存ringData
                                pushTimeRing(ringSecond, jobInfo.getId());

                                // 3、fresh next
                                refreshNextValidTime(jobInfo, new Date(jobInfo.getTriggerNextTime()));

                            }

                        }

                        // 3、update trigger info
                        // 触发完一轮后更新数据库（主要更新下次触发时间
                        for (XxlJobInfo jobInfo: scheduleList) {
                            XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleUpdate(jobInfo);
                        }

                    } else {
                        preReadSuc = false;
                    }

                    // tx stop


                } catch (Exception e) {
                    if (!scheduleThreadToStop) {
                        logger.error(">>>>>>>>>>> xxl-job, JobScheduleHelper#scheduleThread error:{}", e);
                    }
                } finally {

                    // commit
                    if (conn != null) {
                        try {
                            conn.commit();
                        } catch (SQLException e) {
                            if (!scheduleThreadToStop) {
                                logger.error(e.getMessage(), e);
                            }
                        }
                        try {
                            conn.setAutoCommit(connAutoCommit);
                        } catch (SQLException e) {
                            if (!scheduleThreadToStop) {
                                logger.error(e.getMessage(), e);
                            }
                        }
                        try {
                            conn.close();
                        } catch (SQLException e) {
                            if (!scheduleThreadToStop) {
                                logger.error(e.getMessage(), e);
                            }
                        }
                    }

                    // close PreparedStatement
                    if (null != preparedStatement) {
                        try {
                            preparedStatement.close();
                        } catch (SQLException e) {
                            if (!scheduleThreadToStop) {
                                logger.error(e.getMessage(), e);
                            }
                        }
                    }
                }
                // 计算任务触发花费时间
                long cost = System.currentTimeMillis()-start;


                // Wait seconds, align second
                // 触发完成太快就休息一段时间
                if (cost < 1000) {  // scan-overtime, not wait
                    try {
                        // 花费时间在5S内每秒触发一次查询是否有任务要执行
                        // 感觉存在误差，导致任务无法执行的情况
                        // pre-read period: success > scan each second; fail > skip this period;
                        TimeUnit.MILLISECONDS.sleep((preReadSuc?1000:PRE_READ_MS) - System.currentTimeMillis()%1000);
                    } catch (InterruptedException e) {
                        if (!scheduleThreadToStop) {
                            logger.error(e.getMessage(), e);
                        }
                    }
                }

            }

            logger.info(">>>>>>>>>>> xxl-job, JobScheduleHelper#scheduleThread stop");
        }
    });
    scheduleThread.setDaemon(true);
    scheduleThread.setName("xxl-job, admin JobScheduleHelper#scheduleThread");
    scheduleThread.start();


    // ring thread
    // 开启ring线程读取任务执行
    ringThread = new Thread(new Runnable() {
        @Override
        public void run() {

            // align second
            // 时间对齐，转为秒为单位
            try {
                TimeUnit.MILLISECONDS.sleep(1000 - System.currentTimeMillis()%1000 );
            } catch (InterruptedException e) {
                if (!ringThreadToStop) {
                    logger.error(e.getMessage(), e);
                }
            }

            while (!ringThreadToStop) {

                try {
                    // second data
                    List<Integer> ringItemData = new ArrayList<>();
                    int nowSecond = Calendar.getInstance().get(Calendar.SECOND);   // 避免处理耗时太长，跨过刻度，向前校验一个刻度；
                    for (int i = 0; i < 2; i++) {
                        // 获取某一秒的整体运行队列并从缓存ingData中剔除
                        List<Integer> tmpData = ringData.remove( (nowSecond+60-i)%60 );
                        if (tmpData != null) {
                            ringItemData.addAll(tmpData);
                        }
                    }

                    // ring trigger
                    logger.debug(">>>>>>>>>>> xxl-job, time-ring beat : " + nowSecond + " = " + Arrays.asList(ringItemData) );
                    if (ringItemData.size() > 0) {
                        // do trigger
                        for (int jobId: ringItemData) {
                            // do trigger
                            JobTriggerPoolHelper.trigger(jobId, TriggerTypeEnum.CRON, -1, null, null, null);
                        }
                        // clear
                        ringItemData.clear();
                    }
                } catch (Exception e) {
                    if (!ringThreadToStop) {
                        logger.error(">>>>>>>>>>> xxl-job, JobScheduleHelper#ringThread error:{}", e);
                    }
                }

                // next second, align second
                try {
                    TimeUnit.MILLISECONDS.sleep(1000 - System.currentTimeMillis()%1000);
                } catch (InterruptedException e) {
                    if (!ringThreadToStop) {
                        logger.error(e.getMessage(), e);
                    }
                }
            }
            logger.info(">>>>>>>>>>> xxl-job, JobScheduleHelper#ringThread stop");
        }
    });
    ringThread.setDaemon(true);
    ringThread.setName("xxl-job, admin JobScheduleHelper#ringThread");
    ringThread.start();
}
```

任务真正触发也是调用trigger方法与触发器直接调用接口的机制一致 