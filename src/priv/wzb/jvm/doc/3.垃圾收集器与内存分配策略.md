# 3.垃圾收集器与内存分配策略

## 1.复习

- 什么内存需要回收

  线程私有的内存确定，且随着线程而生灭，较为容易，不用管理

  主要的内存管理区域是堆以及方法区

  方法区收集效率低

  垃圾判定算法

  - 引用计数

    循环引用问题，需要大量额外处理

    接用weakReference来打破循环引用

    判断是否引用并强制修改，对象循环引用判定算法，（之前我的实现是借助容器存储遍历过的节点，遍历过程中发现已经存在某个对象说明存在循环引用）

    存在循环引用打破循环，可采用弱引用，但产生野指针问题，需重构被弱引用回收的对象               

  - 可达性分析

    通过根节点(GC Roots)构建引用树，不在被树引用的就可以被标记清理， 不会产生循环引用的问题

    具体实现OOP 容器加速标记根节点对象

    根节点对象选择：不会被回收的对象

    - 静态变量，常量
    - jvm运行所需对象
    - 线程运行所需对象
    - 栈中方法调用所需对象
    - 被锁住的对象

- 什么时候回收

  什么情况触发GC

  空间不足

- 怎么回收

  垃圾收集算法

  标记-清除

  - 效率随着对象增多而降低
  - 内存碎片
  - CMS

  标记-复制

  - 解决标记清理的内存碎片问题
  - 最大问题内存利用率低，但这个问题在新生代的特性下可以不按1：1来划分而是8:1:1之类的规格划分从而更好的利用内存空间
  - serial parNew Parallel Scvange

  标记-整理

  - 解决空间浪费问题
  - 存在大对象移动负重高的问题
  - parallel Scavenge

  

  分代收集

  分代收集假说

  - 弱分代假说

    大多数对象朝生夕死

  - 强分代假说

    撑过越多次GC的对象越难被回收

  - 跨代收集假说

    跨代收集的对象只是少数，因为存在跨代引用的对象弱难以被回收会进入老年代进而消除跨代

  通过分代来划分出容易执行GC的内存和不易执行GC的内存从而更高效运行GC

  具体实现

  跨代收集需要维护记忆集，将空间按粒度划分可分为 对象 内存块等，卡表来实现记忆集从而更方便的跨代回收

- 三色标记

## 3.5经典垃圾收集器

1. Serial
2. ParNew
3. Parallel Scvange
4. CMS
5. SerialOld
6. Parallel Old



垃圾收集器是垃圾收集算法的实现 

收集器的组合使用随着版本会变更

根据环境选择合适收集器

### 3.5.1Serial

1. 会产生长时间STW
2. 简单，不会产生并发问题

![image-20210707182233665](3.垃圾收集器与内存分配策略.assets/image-20210707182233665.png)

在微服务场景下为每个服务分配的内存不会很多serial在不频繁收集的情况下可能也不错

### 3.5.2 ParNew收集器

Serial的多线程版本

能与CMS收集器配合

-XX：+UseConcMarkSweepGC 激活ParNew+CMS

-XX：+/-UseParNewGC 指定/禁用

JDK9取消ParNew+Serial Old / Serial+CMS

XX：ParallelGCThreads 限制收集线程数



> ·并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。·并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。

并行指多个GC线程互相合作，在多线程场景下也可能是并发

这里的并发语义指GC线程与用户线程的运行情况，是交替运行还是暂停用户线程只允许GC线程

### 3.5.3 Parallel Scavenge

与CMS对比

- CMS注重用户线程的低延迟低停顿
- Parallel Scavenge注重吞吐量（大量时间给用户线程运行）

> 如果读者对于收集器运作不太了解，手工优化存在困难的话，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成也许是一个很不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用-XX：MaxGCPauseMillis参数（更关注最大停顿时间）或-XX：GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。

PS+PO

![image-20210712122041535](3.垃圾收集器与内存分配策略.assets/image-20210712122041535.png)

实际上不管如何，Serial/Parallel 都是需要STW的，区别在于单线程还是多线程收集，或者说关注收集细节，但实质上还是STW

### 3.5.6 CMS收集器

解决GC时产生的STW导致服务不可用

> CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。

分为四个步骤

1. 初始标记

2. 并发标记

   时间长但是可与用户线程并发执行

   通过三色算法，主要的思想就是在标记的过程中一旦对象的引用发生改变则记录下来，标记完成后发现还有问题就从对象引用关系变化处重新搜索标记

3. 重新标记

   解决并发标记阶段由并发执行用户线程产生的引用变化问题

4. 并发清除



![image-20210712122523856](3.垃圾收集器与内存分配策略.assets/image-20210712122523856.png)

由于最耗时的两个阶段与用户线程并发执行，所以总体而言可看作与用户线程并发执行的收集器。

> CMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。



但CMS堆CPU的要求高,核心数少说明处理线程能力弱，多线程带来的切换负担增加反而可能降低性能。

由于采用标记-清理 算法 所以没有连续空间分配对象内存的时候会产生Full GC 并且是带着整理的，这段对象移动产生的消耗无法变短。（shenandoah/ZGC 可进行并发移动对象）



### 3.5.7 Garbage First 收集器

基于Region的内存布局与管理。

JDK9后G1是默认收集器取代PS+PO。

JDK10后进行实现解耦，抽取接口实现与抽象分离从而方便编译器的扩展与替换也进一步替换CMS。

G1将内存划分为一个个区域，区域又被标记为新生代（Eden、Survivor）、老年代 。

跨代引用问题，需要采用双向卡表结构来解决，额外消耗内存大约10%-20%左右的内存用户解决跨代引用问题。

**并发运行问题**

1. CMS通过增量更新
2. G1采用原始快照SATB

> 相比起增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。

**运行过程**

1. 初始标记

   与MinorGC同步进行，实际不消耗时间

2. 并发标记

3. 最终标记

   SWT处理SATB

4. 筛选回收

   存活对象移动到空的region再整体清空region，但可根据用户指定的期望时间来定制回收计划。

   ![image-20210712124128200](3.垃圾收集器与内存分配策略.assets/image-20210712124128200.png)



并发收集器选择

> 按照笔者的实践经验，目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间，当然，以上这些也仅是经验之谈，不同应用需要量体裁衣地实际测试才能得出最合适的结论，随着HotSpot的开发者对G1的不断优化，也会让对比结果继续向G1倾斜。





## 3.6低延迟垃圾收集器

衡量垃圾收集器的指标

- 内存占用（footprint）
- 吞吐量（throughput）
- 低延迟（latency）



硬件提升 内存扩大 提高吞吐量 要被回收的内存也更多，将提高延迟通过三色标记算法并发执行GC以及用户线程从而提高效率

CMS会带来内存碎片问题从而STW G1虽然通过粒度细化减少停顿但毕竟还是有停顿

![image-20210713164504555](3.垃圾收集器与内存分配策略.assets/image-20210713164504555.png)

### 3.6.1shenandoah

目标:任何内存大小下都只有10ms停顿

G1后继者，G1借助shenandoah实现多线程Full GC

> Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题（见3.4.4节）的发生概率

工作流程

- 初始标记

- 并发标记

- 最终标记

- 并发清理

  清理无存活对象的region与G1不同

- 并发回收

  将回收集存活对象移动到其他空闲区域

  通过读屏障和BrooksPointers 解决对象转移的与用户线程一起运行的并发问题

  并发回收阶段运行的时间长短取决于回收集的大小。

- 初始引用更新

  设置线程集合点，准备引用更新

- 并发引用更新

  不需要遍历对象图的更新

- 最终引用更新

  修改GC Roots中的引用

- 并发清理

  引用更新后所有的回收集都不存在存活对象，此时全部清空即可

**若访问过期对象通过保护陷阱自动转发对象引用**

> Brooks提出的新方案不需要用到内存保护陷阱，而是在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己

使用CAS解决对象移动与对象变化产生的并发问题



**对象访问通过内存屏障解决并发问题，读屏障比写屏障多 shenandoah使用读屏障，后改为引用访问屏障降低原生操作的影响**

### 3.6.2 ZGC

> ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。

shenandoah基于G1 使用分代，使用读屏障 三色标记，brook pointer

ZGC的Region具有动态性，容量分为小（256KB）、中（4MB）、大（4MB以上）。复制大对象代价昂贵

**并发整理**

- shenandoah使用读屏障+brook pointer(转发指针)

- ZGC使用染色指针

  > ZGC的染色指针是最直接的、最纯粹的，它直接把标记信息记在引用对象的指针上，这时，与其说可达性分析是遍历对象图来标记对象，还不如说是遍历“引用图”来标记“引用”了。
  >
  > ZGC的染色指针技术继续盯上了这剩下的46位指针宽度，将其高4位提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问到



染色指针三大优势

- region划分更细 其中对象移出后方便回收
- 减少读写屏障使用
- 便于扩展



**运行过程**

- 并发标记

  > 与G1、Shenandoah不同的是，ZGC的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志位。

- 并发预备重分配

  找到要清理的region

- 并发重分配

  对象移动 **记录转发表** 可自愈，对象引用发生变化第一次根据指针标记了解变化后通过转发表将指针改为正确位置，并且修改标记从而自愈

- 并发重映射

  在下一次遍历时顺便重分配，提高效率，因为自愈功能无须着急进行引用更新



## 3.7选择合适的垃圾收集器

### 3.7.1 Epsilon

不带回收的GC只拥有对象分配，堆内存管理、布局与解释器、编译器、监控子系统写作等功能。

### 3.7.2 收集器的权衡

- 应用程序的关注点

  是更希望程序多运行还是低延迟还是低内存

  分别对应科学计算、面向用户、嵌入式

- 运行环境

  例如操作系统等

- JDK发行商及版本



> ·如果你有充足的预算但没有太多调优经验，那么一套带商业技术支持的专有硬件或者软件解决方案是不错的选择，Azul公司以前主推的Vega系统和现在主推的ZingVM是这方面的代表，这样你就可以使用传说中的C4收集器了。
>
> ·如果你虽然没有足够预算去使用商业解决方案，但能够掌控软硬件型号，使用较新的版本，同时又特别注重延迟，那ZGC很值得尝试。
>
> ·如果你对还处于实验状态的收集器的稳定性有所顾虑，或者应用必须运行在Win-dows操作系统下，那ZGC就无缘了，试试Shenandoah吧。
>
> ·如果你接手的是遗留系统，软硬件基础设施和JDK版本都比较落后，那就根据内存规模衡量一下，对于大概4GB到6GB以下的堆内存，CMS一般能处理得比较好，而对于更大的堆内存，可重点考察一下G1。



参数总结

![image-20210713173534477](3.垃圾收集器与内存分配策略.assets/image-20210713173534477.png)





## 3.8实战:内存分配与回收策略

> Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：自动给对象分配内存以及自动回收分配给对象的内存。

### 3.8.1对象优先在eden分配

对象优先在eden分配，空间不够引发minor gc，若设置了PretenureSizeThreshold 则超过指定大小的对象直接进入老年代

通过-XX：MaxTenuringThreshold设置存活多少次可以进入老年代



### 3.8.2动态对象年龄判定

> 为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到-XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX：MaxTenuringThreshold中要求的年龄。

### 3.8.3 空间分配担保

> 在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。

**Minror GC是否安全取决于老年代是否有足够的连续空间分配新生代要晋升的对象**

## 3.9 本章小结

> 本章介绍了垃圾收集的算法、若干款HotSpot虚拟机中提供的垃圾收集器的特点以及运作原理。通过代码实例验证了Java虚拟机中自动内存分配及回收的主要规则。

**垃圾收集算法**

- 标记-清除
- 标记-整理
- 标记-复制



HotSpot虚拟机中提供的垃圾收集器的特点以及运作原理

1. Serial
2. ParNew
3. Parallel Scavenge
4. CMS
5. Serial Old
6. Parallel Old
7. G1
8. Shenandoah
9. ZGC