# 技术学习分享

spring cloud学完并整理、分享

在教程基础上总结

出一个易于理解的版本进行分享

考虑我们现在要用的组件

wiki

合理利用公司资源

挖下spring源码

IOC

AOP

多线程executor

JVM

spring cloud

## JUC多线程及并发

### volatile

轻量级线程同步机制，保证线程可见性，不保证原子性，禁止指令重排

#### 可见性

![](https://pic4.zhimg.com/80/v2-b098a84eb7598d70913444a991d1759b_720w.jpg)

可见性如何保证？设计JMM Java内存模型

JMM Java内存模型一种抽象规范，描述使用Java导致的内存变动

每个线程都有自己内部的工作内存（栈空间），主存变量共享，但每个线程操作变量都必须在自己的工作内存中操作

线程之间无法访问对方的工作内存因此信息交换都在主存中完成，线程会定期将更新的数据刷到主存/从主存拉取最新的数据，所以在多线程环境下不能保证每个线程操作的都是同一个最新值，会导致多线程的累加引发值覆盖，最终结果与预期不符

加上volatile关键字可保证线程可见每次都去内存中获取最新值

```java
package priv.wzb.multi_threaded_high_concurrent.volatile1;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * @author Satsuki
 * @time 
 * @description:
 */
public class TestVolatile {
//     int num = 0;
    volatile int num = 0;
    // 使用Atomic数据类型保证++操作的原子性
    AtomicInteger numAtom = new AtomicInteger();

    public void addTo60(){
        num = 60;
    }
    public void addPlus(){
//        synchronized (this){
//            num++;
//        }
        num++;
        numAtom.incrementAndGet();

    }

    public static void main(String[] args) {
        // 验证可见性
        TestVolatile testVolatile = new TestVolatile();

//        new Thread(()->{
//            try {
//                TimeUnit.SECONDS.sleep(2);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
//            testVolatile.addTo60();
//            System.out.println(Thread.currentThread().getName() + ":" + testVolatile.num);
//
//
//        },"AAA").start();
//
//        // 不加volatile不可见其他多线程的改动（不会主动去内存中刷新当前线程本地内存中存储的值
//        while (testVolatile.num==0){
//
//        }
//        System.out.println(Thread.currentThread().getName() + "over");

//        // 不保证原子性
        for (int i = 0; i < 20; i++) {
            new Thread(()->{
                for (int j = 0; j < 1000; j++) {
                    testVolatile.addPlus();
                }
            },String.valueOf(i)).start();
        }
        // 保证线程执行完毕
        while (Thread.activeCount()>2){
            Thread.yield();
        }
        System.out.println(testVolatile.num);
        System.out.println(Thread.currentThread().getName() + ":" + testVolatile.numAtom);
    }
}
```

但是++自身就不是原子操作，所以导致最终值还是不准确

volatile保证可见性，不保证原子性

#### JVM内存模型

Java8之前

![](https://user-gold-cdn.xitu.io/2019/10/22/16df19d81ad389b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

Java8的变更

![](https://user-gold-cdn.xitu.io/2019/10/22/16df19d8f942f7c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



#### 禁止指令重排

```java
int a = 0;
boolean flag = false;

public void write() {
   a = 1;
   flag = true;
}

public void read() {
   if (flag){
      a = a + 5;
      System.out.println(a);
   }
}
```

指令重排可能导致write中的两条指令执行顺序颠倒，多线程读写可能导致read读取的flag为false但a已经变为1

不保证原子性

### AtomicInteger

atomic_test

除了使用valatile还可通过Atomic源自类的CAS操作保证数据一致性

incrementAndGet，自增方法，内部实现使用CAS

采用自旋锁的设计思想，不断比较期望值与现有值是否一致，一致则更新否则说明有改动

CAS底层是UnSafe类这个类会直接操作内存，是依赖操作系统底层的原子性操作所以不会产生数据不一致问题



CAS开销大，只能保证共享变量的原子性，引发ABA问题（可通过版本号/时间戳来辅助解决）

XXL中 路由策略，轮询策略使用原子类进行自增，多任务多线程触发场景保证数据安全

```java
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
```

### 集合类

container_safe

List的默认实现集合类是线非线程安全的

集合类的线程不安全问题可通过Collections工具类实现，Vector是早期的线程安全实现方式大量采用synchronized导致效率极低

vector源码:

```java
/**
 * Adds the specified component to the end of this vector,
 * increasing its size by one. The capacity of this vector is
 * increased if its size becomes greater than its capacity.
 *
 * <p>This method is identical in functionality to the
 * {@link #add(Object) add(E)}
 * method (which is part of the {@link List} interface).
 *
 * @param   obj   the component to be added
 */
public synchronized void addElement(E obj) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = obj;
}
```

直接加在了方法上，synchronized通过加锁的方式来保证多线程的线程安全问题，锁的粒度应该越小越好

Collections.synchronizedList(new (线程不安全的容器类))

锁的粒度更小

map/queue之类的集合可使用Concurrent开头的集合类保证集合操作的线程安全，以ConcurrentHashMap举例内部采用synchronized来锁定代码块保证线程安全

```java
package priv.wzb.multi_threaded_high_concurrent.container_safe;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * @author Satsuki
 * @time 
 * @description: 集合类不安全问题
 */
public class ContainerNotSafeDemo {
    public static void main(String[] args) {
        // 并发出错演示
//        List<String> list = new ArrayList<>();


        // 解决方案1：Vector,这个类是加了synchronized的，线程安全
        // 但是耗时严重 public synchronized boolean add(E e) {
        // 直接在方法体上加了
//        List<String> list = new Vector<>();


        // 解决方案2：Collections.synchronizedList(new (线程不安全的容器类))
        // public void add(int index, E element) {
        //            synchronized (mutex) {list.add(index, element);}
        //        }
        // 可见，传入一共线程不安全的list，在Collections内部会自动创建一共线程安全的list
        // 这个相对于vector锁的粒度更小并没有锁定方法体，而是锁了代码块
        // 使用synchronzed
        // final Object mutex;     // Object on which to synchronize
        // mutex是线程锁定对象
        List<String> list = Collections.synchronizedList(new ArrayList<>());
//        list.add("11");


        // 解决方案3 ： CopyOnWriteArrayList
        // /** The lock protecting all mutators */
        //    final transient ReentrantLock lock = new ReentrantLock();
        //
        //    /** The array, accessed only via getArray/setArray. */
        //    private transient volatile Object[] array;
        // 使用reentrantlock可重入锁
        // 数组采用volatile修饰，阻止指令重排，保证可见性，操作原子性由lock保证
        // /**
        //     * Appends the specified element to the end of this list.
        //     *
        //     * @param e element to be appended to this list
        //     * @return {@code true} (as specified by {@link Collection#add})
        //     */
        //    public boolean add(E e) {
        //        final ReentrantLock lock = this.lock;
        //        lock.lock();
        //        try {
        //            Object[] elements = getArray();
        //            int len = elements.length;
        //            Object[] newElements = Arrays.copyOf(elements, len + 1);
        //            newElements[len] = e;
        //            setArray(newElements);
        //            return true;
        //        } finally {
        //            lock.unlock();
        //        }
        //    }
        // 可见其add方法的过程是
        // 加锁
        // 复制产生新的数组
        // 将要加入的值放入新数组
        // 将数组指向新数组
        // 解锁
//        List<String> list = new CopyOnWriteArrayList<>();



        // 多个线程写
//        for (int i = 0; i < 100; i++) {
//            new Thread(()->{
//                list.add(UUID.randomUUID().toString().substring(1,8));
//                System.out.println(list);
//            },String.valueOf(i)).start();
//        }

        // 报错 java.util.ConcurrentModificationException
        // 原因：多线程争抢修改
        // 解决方案
        // Vector/Collections.synchronized/CopyOnWrite


        // 测试set和map
        // 出错：java.util.ConcurrentModificationException
        // 解决方案与list相似
//        Set<String> set = new HashSet<>();
//        Set<String> set = Collections.synchronizedSet(new HashSet<>());
        Set<String> set = new CopyOnWriteArraySet<>();


//        for (int i = 0; i < 100; i++) {
//            new Thread(()->{
//                // subString[)
//                set.add(UUID.randomUUID().toString().substring(2,8));
//                System.out.println(set);
//            },String.valueOf(i)).start();
//        }


        // 测试map

        // 出错:java.util.ConcurrentModificationException
//        Map<String,String> map = new HashMap<>();
//        Map<String,String> map = Collections.synchronizedMap(new HashMap<>());
        Map<String,String> map = new ConcurrentHashMap<>();

        // 在ConcurrentHashMap中将可能出错的关键代码加入了synchronized进行代码块锁定
        //synchronized (f) {
        //                    if (tabAt(tab, i) == f) {
        //                        if (fh >= 0) {
        //                            binCount = 1;
        //                            for (Node<K,V> e = f;; ++binCount) {
        //                                K ek;
        //                                if (e.hash == hash &&
        //                                    ((ek = e.key) == key ||
        //                                     (ek != null && key.equals(ek)))) {
        //                                    oldVal = e.val;
        //                                    if (!onlyIfAbsent)
        //                                        e.val = value;
        //                                    break;
        //                                }
        //                                Node<K,V> pred = e;
        //                                if ((e = e.next) == null) {
        //                                    pred.next = new Node<K,V>(hash, key,
        //                                                              value, null);
        //                                    break;
        //                                }
        //                            }
        //                        }
        //                        else if (f instanceof TreeBin) {
        //                            Node<K,V> p;
        //                            binCount = 2;
        //                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
        //                                                           value)) != null) {
        //                                oldVal = p.val;
        //                                if (!onlyIfAbsent)
        //                                    p.val = value;
        //                            }
        //                        }
        //                    }
        //                }

        for (int i = 0; i < 100; i++) {
            new Thread(()->{
                map.put(UUID.randomUUID().toString().substring(2,8),UUID.randomUUID().toString().substring(2,8));
                System.out.println(map);
            },String.valueOf(i)).start();



        }


    }
}
```

### ReentrantLock

thread_reentrantlock

Java早期版本使用synchronized关键字锁定某个对象保证数据安全

现在使用ReentrantLock较多，更加灵活与方便扩展在初始化通过指定true/false指定是否是公平锁(默认非公平)

可重入锁

锁的传递性

两者都是可重入锁（避免死锁

两者比较：

- ReentrantLock可以完成synchronized的功能所以可以替代synchronized

  ```java
  package priv.wzb.multi_threaded_high_concurrent.thread_reentrantlock;
  
  import java.util.concurrent.TimeUnit;
  
  /**
   * @author Satsuki
   * @time 
   * @description:ReentrantLock可以完成synchronized的功能所以可以替代synchronized
   */
  public class ReentrantLock1 {
      synchronized void m1(){
          for(int i =0;i<10;i++){
              try {
                  TimeUnit.SECONDS.sleep(1);
              }catch (InterruptedException e){
                  e.printStackTrace();
              }
              System.out.println(i);
          }
      }
      synchronized void m2(){
          System.out.println("m2...");
      }
  
      public static void main(String[] args){
          ReentrantLock1 r1 = new ReentrantLock1();
          new Thread(r1::m1).start();
          try {
              TimeUnit.SECONDS.sleep(1);
          }catch (InterruptedException e){
              e.printStackTrace();
          }
          new Thread(r1::m2).start();
      }
  }
  ```

- ReentrantLock比synchronized灵活 可以使用tryLock尝试锁定
  * 尝试锁定不管锁定与否都将继续执行也可以根据返回值判定是否锁定
  * 可以制定tryLock的时间，由于tryLock(time)抛出异常，
  * 所以要注意unlock的操作必须放到finally中
  
  ```java
  package priv.wzb.multi_threaded_high_concurrent.thread_reentrantlock;
  
  import java.util.concurrent.TimeUnit;
  import java.util.concurrent.locks.Lock;
  import java.util.concurrent.locks.ReentrantLock;
  
  /**
   * @author Satsuki
   * @time 
   * @description:ReentrantLock比synchronized灵活 可以使用tryLock尝试锁定
   * 尝试锁定不管锁定与否都将继续执行也可以根据返回值判定是否锁定
   * 可以制定tryLock的时间，由于tryLock(time)抛出异常，
   * 所以要注意unlock的操作必须放到finally中
   */
  public class ReentrantLock2 {
      Lock lock = new ReentrantLock();
      void m1(){
          lock.lock();
          try {
              for(int i = 0;i< 10 ;i++){
                  TimeUnit.SECONDS.sleep(1);
                  System.out.println(i);
              }
          }catch (InterruptedException e){
              e.printStackTrace();
          }finally {
              lock.unlock();
          }
      }
  
      void m2(){
  
          boolean locked = false;
          try {
              locked = lock.tryLock(1000, TimeUnit.MILLISECONDS);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println("m2..." + locked);
          if (locked) lock.unlock();
  //        lock.lock();
  //        System.out.println("m2...");
      }
  
      public static void main(String[] args){
          ReentrantLock2 r2 = new ReentrantLock2();
          new Thread(r2::m1).start();
          new Thread(r2::m2).start();
      }
  }
  ```
  
- 可以通过interrupt来打断

  ```java
  package priv.wzb.multi_threaded_high_concurrent.thread_reentrantlock;
  
  
  import java.util.concurrent.TimeUnit;
  import java.util.concurrent.locks.Lock;
  import java.util.concurrent.locks.ReentrantLock;
  
  /**
   * @author Satsuki
   * @time 
   * @description:可以通过interrupt来打断
   */
  public class ReentrantLock3 {
  //    public ReentrantLock void test(){
  //        System.out.println("aaa");
  //    }
      public static void main(String[] args) {
          Lock lock = new ReentrantLock();
  
          Thread t1 = new Thread(() -> {
              try {
                  lock.lock();
                  System.out.println("t1.start");
                  TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);
              } catch (InterruptedException e) {
                  System.out.println("interrupted!");
                  e.printStackTrace();
              } finally {
                  lock.unlock();
              }
          });
          t1.start();
  
          Thread t2 = new Thread(() -> {
              try {
                  lock.lockInterruptibly();
                  System.out.println("t2 start");
                  TimeUnit.SECONDS.sleep(5);
                  System.out.println("t2 end");
              } catch (InterruptedException e) {
                  System.out.println("interrupted");
                  e.printStackTrace();
              } finally {
                  lock.unlock();
              }
  
          });
          t2.start();
  
          try {
              TimeUnit.SECONDS.sleep(1);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          t2.interrupt();//打断线程2的等待
  
      }
  }
  ```

- ReentrantLock可以指定为公平锁，synchronized是非公平锁，非公平锁可能导致线程饿死，一直得不到执行

  ```java
  package priv.wzb.multi_threaded_high_concurrent.thread_reentrantlock;
  
  import java.util.concurrent.locks.ReentrantLock;
  
  
  /**
   * @author Satsuki
   * @time 
   * @description:ReentrantLock可以指定为公平锁，
   * 公平锁就是哪个线程等待时间长就哪个线程先执行
   * ReentrantLock必须要在finally中unlock(), 否则,如果在被加锁的代码中抛出了异常,那么这个锁将会永远无法释放.
   */
  public class ReentantLock4 extends Thread {
      private static ReentrantLock lock = new ReentrantLock(true);
      public void run(){
          for(int i = 0 ;i<100;i++){
              lock.lock();
              try {
                  System.out.println(Thread.currentThread().getName() + "获得锁");
              }finally {
                  lock.unlock();
              }
          }
      }
  
      public static void main(String[] args){
          ReentantLock4 r4 = new ReentantLock4();
          Thread th1 = new Thread(r4);
          Thread th2 = new Thread(r4);
          th1.start();
          th2.start();
  
      }
  }
  ```

  





### 独占锁(写)/共享锁(读)/互斥锁

read_write_lock

写锁是排他锁代表写操作执行完成之前不能执行其他写操作

读锁是共享锁读操作完成之前允许其他操作

```java
package priv.wzb.multi_threaded_high_concurrent.read_write_lock;


import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;

// 资源类
class MyCache{
    // 这里模拟缓存所以需要加上volatile保证可见性
    private volatile Map<String,Object> map = new HashMap<>();
//    private Lock lock = new ReentrantLock();
    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();


    public void put(String key,Object value){
        rwLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t 正在写：" +key);
            // 模拟延迟，暂停线程
            try {
                TimeUnit.MILLISECONDS.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            map.put(key,value);
            System.out.println(Thread.currentThread().getName() + "\t 写入完成");
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            rwLock.writeLock().unlock();
        }
//        System.out.println(Thread.currentThread().getName() + "\t 正在写：" +key);
//        // 模拟延迟，暂停线程
//        try {
//            TimeUnit.MILLISECONDS.sleep(300);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//        map.put(key,value);
//        System.out.println(Thread.currentThread().getName() + "\t 写入完成");
    }


    public void get(String key){
        rwLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t 正在读取：" +key);
            // 模拟延迟，暂停线程
            try {
                TimeUnit.MILLISECONDS.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            Object result = map.get(key);
            System.out.println(Thread.currentThread().getName() + "\t 读取完成:" + result);
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            rwLock.readLock().unlock();
        }
//        System.out.println(Thread.currentThread().getName() + "\t 正在读取：" +key);
//        // 模拟延迟，暂停线程
//        try {
//            TimeUnit.MILLISECONDS.sleep(300);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//        Object result = map.get(key);
//        System.out.println(Thread.currentThread().getName() + "\t 读取完成:" + result);
    }

    // 缓存三大操作，读、写、清除
    public void clearMap(){
        map.clear();
    }

}

/**
 * @author Satsuki
 * @time 
 * @description:
 * 读写锁
 * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该同时进行
 * 但是
 * 如果一个线程想进去写共享资源，就不应该再有其他线程可以对该资源进行读或写
 * 小总结：
 * 读-读能共存
 * 读-写不能共存
 * 写-写不能共存
 *
 * 写操作：原子+独占，整个过程必须是一个完整的过程无法被打断
 */
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache myCache = new MyCache();
        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(()->{
                myCache.put(tempInt+"",tempInt+"");
            },String.valueOf(i)).start();
        }


        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(()->{
                myCache.get(tempInt+"");
            },String.valueOf(i)).start();
        }

    }
}
```

### CountDownLatch/CyclicBarrier/Semaphore

CountDownLatch线程的异步转同步，控制多线程下，线程顺序执行

加入CountDownLatch让异步的多线程转为同步执行

```java
package priv.wzb.multi_threaded_high_concurrent.countdown_latch;

import java.util.concurrent.CountDownLatch;

/**
 * @author Satsuki
 * @time 
 * @description:
 */
public class CountDownLatchDemo {
    public static void main(String[] args) {
        CountDownLatch countDownLatch = new CountDownLatch(6);
        for (int i = 1; i <= 6; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName() + "\t上完自习，离开教室");
                countDownLatch.countDown();
            },String.valueOf(i)).start();
        }

        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "\t   main最后离开教室，释放资源");


    }
}
```

CyclicBarrier 等到多个线程执行完毕后再继续执行

```java
package priv.wzb.multi_threaded_high_concurrent.cyclic_barrier;

import java.util.concurrent.CyclicBarrier;

/**
 * @author Satsuki
 * @time 
 * @description:
 */
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()->{
            System.out.println("召唤神龙");
        });

        for (int i = 1; i <= 7; i++) {
            final int tempInt = i;
            new Thread(()->{
                System.out.println(Thread.currentThread().getName() + "\t 收集到第" + tempInt + "龙珠");
                try {
                    cyclicBarrier.await();
                }catch (Exception e){
                    e.printStackTrace();
                }
            },String.valueOf(i)).start();
        }
    }
}
```

Semaphore 信号量 信号量的主要用户两个目的,一个是用于多个共享资源的相互排斥使用,另一个用于并发资源数的控制.

```java
package priv.wzb.multi_threaded_high_concurrent.semaphore;

import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * @author Satsuki
 * @time 
 * @description:
 */
public class SemaphoreDemo {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3);// 模拟三个停车位

        for (int i = 1; i <= 6; i++) {
            // 模拟六部汽车
            new Thread(()->{
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName()+"\t 抢到车位");
                    TimeUnit.SECONDS.sleep(3);
                    System.out.println(Thread.currentThread().getName()+"\t 3S后离开车位");
                }catch (InterruptedException e){
                    e.printStackTrace();
                }finally {
                    semaphore.release();
                }
            },String.valueOf(i)).start();

        }
    }
}
```

### 线程池

线程池可控制线程运行的数量

线程池内部使用阻塞队列保存线程要执行的任务逻辑

ThreadPoolExecutor

优点：

1. 降低每次重复创建线程带来的资源消耗
2. 提高响应速度，减去新建线程的时间
3. 提高可管理性，由线程池统一分配调度

Java固定实现的主要线程池：



- Executors.newFixedThreadPool(int)

  执行一个长期的任务,性能好很多

  主要特点如下:
  1.创建一个定长线程池,可控制线程的最大并发数,超出的线程会在队列中等待.
  2.newFixedThreadPool创建的线程池corePoolSize和MaxmumPoolSize是 相等的,它使用的的LinkedBlockingQueue

  ```java
  package priv.wzb.multi_threaded_high_concurrent.thread_pool;
  
  import java.util.concurrent.*;
  
  /**
   * @author Satsuki
   * @time 
   * @description:
   */
  public class T05_FixedThreadPool {
      public static void main(String[] args) throws InterruptedException {
          ExecutorService service = Executors.newFixedThreadPool(5);
  
          for (int i = 0; i < 6; i++) {
              service.execute(()->{
                  try {
                      TimeUnit.MILLISECONDS.sleep(500);
                  }catch (InterruptedException e){
                      e.printStackTrace();
                  }
                  System.out.println(Thread.currentThread().getName());
              });
  
          }
          System.out.println(service);
          System.out.println(service.isTerminated());
          System.out.println(service.isShutdown());
          System.out.println(service);
  
          TimeUnit.SECONDS.sleep(50);
  
          System.out.println(service.isTerminated());
          System.out.println(service.isShutdown());
          System.out.println(service);
      }
  }
  ```

- Executors.newSingleThreadExecutor()

  一个任务一个线程执行的任务场景

  主要特点如下:
  1.创建一个单线程化的线程池,它只会用唯一的工作线程来执行任务,保证所有任务都按照指定顺序执行.
  2.newSingleThreadExecutor将corePoolSize和MaxmumPoolSize都设置为1,它使用的的LinkedBlockingQueue

  ```java
  package priv.wzb.multi_threaded_high_concurrent.thread_pool;
  
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;
  
  /**
   * @author Satsuki
   * @time 
   * @description:
   */
  public class SingleThreadPool {
      public static void main(String[] args) {
          ExecutorService service = Executors.newSingleThreadExecutor();
          for (int i = 0; i < 5; i++) {
              final int j=i;
              service.execute(()->{
                  System.out.println(j+" "+ Thread.currentThread().getName());
                  // 即使出错之后也不会停止运行，会创建一个新的线程来继续执行
                  int x = 1/0;
              });
          }
      }
  }
  ```

- Executors.newCachedThreadPool()

  适用:执行很多短期异步的小程序或者负载较轻的服务器

   主要特点如下:
  1.创建一个可缓存线程池,如果线程池长度超过处理需要,可灵活回收空闲线程,若无可回收,则创建新线程.
  2.newCachedThreadPool将corePoolSize设置为0MaxmumPoolSize设置为Integer.MAX_VALUE,它使用的是SynchronousQUeue,也就是说来了任务就创建线程运行,如果线程空闲超过60秒,就销毁线程
  
  ```java
  package priv.wzb.multi_threaded_high_concurrent.thread_pool;
  
  import java.util.concurrent.*;
  
  /**
   * @author Satsuki
   * @time 
   * @description:
   */
  
  /**
   *创建一个根据需要创建新线程的线程池，但是
   *将重用以前构造的线程
   *可用。 这些池通常会提高性能
   *执行许多短期异步任务的程序。
   *调用{@code execute}将重用以前构建的
   *线程（如果有）。 如果没有可用的现有线程，则为新的
   *将创建线程并将其添加到池中。 有线程的
   *未使用60秒被终止并从中删除
   *缓存。 因此，一个长时间闲置的游泳池将会
   *不消耗任何资源。 请注意，池类似
   *属性但不同的细节（例如，超时参数）
   *可以使用{@link ThreadPoolExecutor}构造函数创建。
   *
   * @return新创建的线程池
   */
  public class T08_CachedPool {
      public static void main(String[] args) throws InterruptedException {
          ExecutorService service = Executors.newCachedThreadPool();
          ExecutorService service1 = new ThreadPoolExecutor(
                  1,
                  1,
                  1,
                  TimeUnit.SECONDS,
                  new LinkedBlockingQueue<>(),
                  new ThreadFactory() {
                      @Override
                      public Thread newThread(Runnable r) {
                          return new Thread(r,"threadName");
                      }
                  });
  
          System.out.println(service);
  
          for (int i = 0; i < 2; i++) {
              service.execute(()->{
                  try {
                      TimeUnit.MILLISECONDS.sleep(500);
                  }catch (InterruptedException e){
                      e.printStackTrace();
                  }
                  System.out.println(Thread.currentThread().getName());
              });
          }
          System.out.println(service);
          TimeUnit.SECONDS.sleep(8);
          System.out.println(service);
      }
  }
  ```

三种线程池的比较可以根据源码进行分析

- 单例线程池可以看到线程池中只有一个线程
- newFixedThreadPool则可以指定

实际是通过建立线程池指定固定参数实现的

推荐根据需求自动建立线程池而不适用Executors来创建现有的线程池

自建线程池参数介绍

1. corePoolSize:线程池中的常驻核心线程数

   1.在创建了线程池后,当有请求任务来之后,就会安排池中的线程去执行请求任务,近视理解为今日当值线程
   2.当线程池中的线程数目达到corePoolSize后,就会把到达的任务放入到缓存队列当中.

2. maximumPoolSize:线程池能够容纳同时执行的最大线程数,此值大于等于1

3. keepAliveTime:多余的空闲线程存活时间,当空间时间达到keepAliveTime值时,多余的线程会被销毁直到只剩下corePoolSize个线程为止

   默认情况下:
   只有当线程池中的线程数大于corePoolSize时keepAliveTime才会起作用,知道线程中的线程数不大于corepoolSIze,

4. unit:keepAliveTime的单位

5. workQueue:任务队列,被提交但尚未被执行的任务.

6. threadFactory:表示生成线程池中工作线程的线程工厂,用户创建新线程,一般用默认即可

7. handler:拒绝策略,表示当线程队列满了并且工作线程大于等于线程池的最大显示 数(maxnumPoolSize)时如何来拒绝.

6和7一般使用默认的

内置拒绝策略：

JDK内置的拒绝策略

1. AbortPolicy(默认):直接抛出RejectedException异常阻止系统正常运行
2. CallerRunPolicy:"调用者运行"一种调节机制,该策略既不会抛弃任务,也不会抛出异常,而是直接拒绝任务
3. DiscardOldestPolicy:抛弃队列中等待最久的任务,然后把当前任务加入队列中尝试再次提交
4. DiscardPolicy:直接丢弃任务,不予任何处理也不抛出异常.如果允许任务丢失,这是最好的拒绝策略

以上内置策略均实现了RejectExecutionHandler接口

线程池以XXL的作为例子讲解初始化参数

com.xxl.job.admin.core.thread.JobTriggerPoolHelper

使用线程池execute方法实现runnable接口实现运行逻辑执行远程调用



### 阻塞队列

在队列为满/空的时候阻塞添加/获取的请求

用于线程的挂起与继续执行

队列满采用CAS的方式去不断判断知道队列有位置

```java
    /**
     * Inserts the specified element at the tail of this queue, waiting
     * for space to become available if the queue is full.
     *
     * @throws InterruptedException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     */
    public void put(E e) throws InterruptedException {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == items.length)
                notFull.await();
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
```

add/remove

offer/poll

put/take





## HashMap底层源码

JDK1.8后的HashMap结构

![](https://img-blog.csdn.net/20170803204952538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG9naW5fc29uYXRh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 初始化

```java
/**
 * Returns a power of two size for the given target capacity.
 */
static final int tableSizeFor(int cap) {
    // 防止2的整数倍
    int n = cap - 1;
    // 寻找最接近的2的幂并返回
    // 通过无符号右移+或自身，将有值开始的二进制都填充为1
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    // 一个超出判定，未超出界限（下界和上界）+1就是2的幂并返回
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

初始化threshold

怎么理解呢？**其实是对一个二进制数依次向右移位，然后与原值取或。**其目的对于一个数字的二进制，从第一个不为0的位开始，把后面的所有位都设置成1。

例如：

```java
1100 1100 1100 >>>1 = 0110 0110 0110
1100 1100 1100 | 0110 0110 0110 = 1110 1110 1110
1110 1110 1110 >>>2 = 0011 1011 1011
1110 1110 1110 | 0011 1011 1011 = 1111 1111 1111
1111 1111 1111 >>>4 = 1111 1111 1111
1111 1111 1111 | 1111 1111 1111 = 1111 1111 1111

```

通过几次`无符号右移`和`按位或`运算，我们把1100 1100 1100转换成了1111 1111 1111 ，再把1111 1111 1111加1，就得到了1 0000 0000 0000，这就是大于1100 1100 1100的第一个2的幂。

无符号位右移，左侧添0


```java
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                           initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                           loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}
 
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}
public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}
 
public HashMap(Map<? extends K, ? extends V> m) {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);
}
```

  

构造方法一共重载了四个，主要初始化了三个参数：

- initialCapacity 初始容量（默认16）： hashMap底层由数组实现+链表（或红黑树）实现，但是还是从数组开始，所以当储存的数据越来越多的时候，就必须进行扩容操作，如果在知道需要储存数据大小的情况下，指定合适的初始容量，可以避免不必要的扩容操作，提升效率
- threshold 阈值：hashMap所能容纳的最大价值对数量，如果超过则需要扩容，计算方式：threshold=initialCapacity*loadFactor（构造方法中直接通过tableSizeFor(initialCapacity)方法进行了赋值，主要原因是在构造方法中，数组table并没有初始化，put方法中进行初始化，同时put方法中也会对threshold进行重新赋值，这个会在后面的源码中进行分析）
- loadFactor 加载因子（默认0.75）：当负载因子较大时，去给table数组扩容的可能性就会少，所以相对占用内存较少（空间上较少），但是每条entry链上的元素会相对较多，查询的时间也会增长（时间上较多）。反之就是，负载因子较少的时候，给table数组扩容的可能性就高，那么内存空间占用就多，但是entry链上的元素就会相对较少，查出的时间也会减少。所以才有了负载因子是时间和空间上的一种折中的说法。所以设置负载因子的时候要考虑自己追求的是时间还是空间上的少。（一般情况下不需要设置，系统给的默认值已经比较适合了）



### PUT

```java
/**
 * Implements Map.put and related methods.
 * 实现Map.put及相关方法
 *
 * @param hash hash for key
 * @param key the key
 * @param value the value to put
 * @param onlyIfAbsent if true, don't change existing value
 * @param evict if false, the table is in creation mode.
 * @return previous value, or null if none
 */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    // 将table赋值给tab 进行长度判断如果table为null或长度为0
    if ((tab = table) == null || (n = tab.length) == 0)
        // 初始化table数组长度
        // 将n定义为table数组长度
        n = (tab = resize()).length;
    // 根据hash判断要进行存储的键值对应该存在table数组中的哪个table
    // 将第i个table的头节点赋值给p 如果该table为空
    if ((p = tab[i = (n - 1) & hash]) == null)
        // 新建节点作为table数组中第i个table所代表的数据结构（i是根据table数组长度与hash值相与计算得出
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
        // 首先对p的hash值判断是否等于要插入key所代表的hash值
        if (p.hash == hash &&
            // 将p的key赋值给k如果k等于要插入的key（基本数据类型的判断）或k不为null且key调用equals方法判断是否与k相等
            ((k = p.key) == key || (key != null && key.equals(k))))
            // 将p赋值给e节点（此时找到相同的key记录
            e = p;
        // 若没有找到相同的key记录且如果p是树节点调用TreeNode的putTreeVal方法去插入数据
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        // 如果p不是树节点（table所代表的数据结构还是链表，大小未达到树化阈值
        else {
            // 循环
            for (int binCount = 0; ; ++binCount) {
                // 将p的下一个节点赋值给e
                // 不停的循环遍历直至p的下一个节点为null
                if ((e = p.next) == null) {
                    // 创建新节点作为p的下一个节点
                    p.next = newNode(hash, key, value, null);
                    // 如果容器计数达到了树化阈值
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        // 将容器树化（将table所代表的链表转换为红黑树
                        treeifyBin(tab, hash);
                    break;
                }
                // 在遍历时根据哈希值与key判断table中是否由相同key的记录如果由则跳出循环
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                // 如果下一个节点不是null将e重新赋值给p代表p向后遍历
                p = e;
            }
        }
        // 如果找到了已经存在相同key的记录
        if (e != null) { // existing mapping for key
            // 将老值保存
            V oldValue = e.value;
            // 默认onlyIfAbsent为false说明要更新值
            // 如果onlyIfAbsent为true则不更新值说明要更新值
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    
    // 对map结构的修改次数+1
    ++modCount;
    // 如果容器大小达到阈值调整容器大小
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
```

分为三种情况

- table未初始化，初始化table

- table已初始化，table中的某个节点未null，新建Node作为头节点放入table对应节点

- table已初始化，hash后映射的节点中不为空，产生hash碰撞

  如果hash映射到同一个空间、key值也相同那么在最后更新现有值

  如果是新值且Node节点已转为红黑树，调用红黑树的插入方法（要进行添加和平衡（变色/旋转

  不是红黑树还是链表就遍历到链表最后，在最后添加新的节点并且判断链表是否达到的树化阈值，达到后将链表转为红黑树提高插入及遍历的性能

- 最后对容器大小进行判断，达到扩容阈值就进行扩容





### GET

```java
/**
 * Returns the value to which the specified key is mapped,
 * or {@code null} if this map contains no mapping for the key.
 * get方法返回指定key所映射的值（value）
 * 如果当前map不包含key的键值映射则返回null
 *
 * <p>More formally, if this map contains a mapping from a key
 * {@code k} to a value {@code v} such that {@code (key==null ? k==null :
 * key.equals(k))}, then this method returns {@code v}; otherwise
 * it returns {@code null}.  (There can be at most one such mapping.)
 *
 * <p>A return value of {@code null} does not <i>necessarily</i>
 * indicate that the map contains no mapping for the key; it's also
 * possible that the map explicitly maps the key to {@code null}.
 * The {@link #containsKey containsKey} operation may be used to
 * distinguish these two cases.
 *
 * @see #put(Object, Object)
 */
public V get(Object key) {
    // 新建节点e
    Node<K,V> e;
    // 调用getNode方法如果节点不为空则返回该节点的value通过hash方法计算key所代表的哈希值以便后续寻找对应的table
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

/**
 * Implements Map.get and related methods.
 * 实现Map.get方法以及相关方法
 *
 * @param hash hash for key
 * @param key the key
 * @return the node, or null if none
 */
final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    // 初始化tab为当前map的table数组 ，如果当前table不为空且table数组的长度大于零且初始化first节点指向根据hash值所对应的table数组中的某个table不为空
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        // 总是要检查first节点的哈希值是否和要查找的hash值相等
        if (first.hash == hash && // always check first node
            // 如果first节点的key与要查询的key相等（primitive）基本数据类型用此判断
            // 或者key不为空且key调用自身equals方法与first节点的key比较如果相等则返回first节点
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        // 上述是如果fitst节点也就是table的头节点正好是要找的节点
        // 下面是table所代表的链表的头节点不是要查找的节点
        // 如果first节点的下一个节点不为null（将first节点所指向的链表的下一个节点赋值给了e）
        if ((e = first.next) != null) {
            // 如果 first节点是树节点
            if (first instanceof TreeNode)
                // 将first节点转为树节点并调用getTreeNode方法（从根节点开始查找）查找对应的节点
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            // 如果first节点并非树节点（还是使用链表作为table的数据结构没有达到树化阈值
            do {
                // 如果e节点的key与要查询的key相等（primitive）基本数据类型用此判断
            	// 或者key不为空且key调用自身equals方法与first节点的key比较如果相等则返回e节点
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
                // 当e的下一个节点不为空时继续循环查找
            } while ((e = e.next) != null);
        }
    }
    return null;
}

```

1.  根据hash值查找到指定位置的数据
2. 校验指定位置第一个节点的数据是否与key相等，如果相等直接返回，否则顺着寻找下一个节点
3. 如果是TreeNode（红黑树结构），直接通过查找红黑树节点数据返回
4. 链表结构则进行链表遍历，找到返回节点，找不到返回null



## JVM+GC



## spring



### IOC



### AOP



## spring cloud