# 第三章 代码的坏味道

> 我们并不试图给你一个何时必须重构的精确衡量标准。从我们的经验看来，没有任何度量规矩比得上一个见识广博者的直觉。我们指挥告诉你一些急响，它会指出“这里有一个可以用重构解决的问题”。你必须培养出自己的判断力，学会判断一个类内又多少实例变量算太大，一个函数内又多少行代码才算太长。

## 3.1 Duplicated Code (重复代码)

坏味道行列中首当其冲的就是Duplicated Code.如果你在一个以上的地点看到相同的程序结构，那么可以肯定:设法将它们合而为一，程序会变得更好。

- Duplicated Code:`同一个类的两个函数含有相同的表达式`
  - 处理方案：采用**Extract Method** 提炼重复代码，让这两个地点都调用被提炼的代码。
- 互为兄弟的子类重复代码
  - 两个类都**Extract Method** 然后再对被提炼出的代码使用 **Pull Up Method**（332） 推入超类
- 若代码类似并不完全相同
  - 需要**Extract Method（110）** 将相似部分和差异部分割开，构成单独函数，运用**Form Template Method(345)** 获得一个Template Method设计模式。
- 如果函数以不同的算法做相同的事
  - 选择清洗的一个使用**Subsititute Algorithm(139)** 将其他函数的算法替换掉
- 完全不想关类的Duplicated Code
  - 对其中一个Extract Class(149) 重复代码体检到独立类，在另一个类内使用新类
    - 需要决定在哪出现更为合适 且 确保不会出现在其他地方

## 3.2 Long Method（过长函数）

> 拥有短函数的对象会获得比较好、比较长。

“间接层”所能带来的全部利益——解释、共享、选择——都是由小型函数支持的

**程序越长越难理解**

- 小函数不会带来额外的开销，取一个好名字便于理解
- 最终效果：更积极地分解函数
- 遵循原则：每当感觉需要以注释来说明点什么的时候就需要把说明的东西写进一个独立函数
- 关在不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离
- 方案
  - extract method
  - 参数过多采用Replace Temp with Query(120)来消除临时元素
  - Introduce Parameter Object(295)和Preserve Whole Object(288) 则可以将过长参数列表变得更为简洁
  - 还是过多参数则采用Replace Method with Method Object(135)
- 做法
  - 寻找注释，哪怕一行代码有必要也可以是一个函数
- 条件表达式和循环也是提炼的信号使用Decompose Conditional(238) 处理条件表达式

## 3.3 Large Class(过大的类)

- 单个类过大容易触发 Duplicated Code
- 采用Extract Class(149)将几个变量提炼至新类。 选择互相关联的放在一起
- 类内相同前缀/后缀就由机会提炼到一个组件。如果这个组件合作为一个子类Extract Subclasss(330)往往比较简单
- 类太大出了分解还可以提炼共同部分
- 方案
  - 先确定客户端如何使用，然后运用Extract Interface(341)未每一种方法提炼一个接口
  - 大类是GUI则把数据和行为移到一个独立的领域对象去并保持同步
    - Duplicate Observed Data(189)告诉你怎么做
- 

## 3.4 Long Parameter List(过长参数列)

- 面向对象简化函数
- 如果向已有的对象发出一条请求就可以取代一个参数，应该激活重构手法**Replace Parameter with Method(292)**
- 已有对象可能是函数所属类内的一个字段也可能是参数，还可以用Preserve Whole Object将同一对象一堆数据收集并替换，缺乏合理对象归属可使用Introduce Parameter Object 未他们制造一个参数对象

## 3.5 Divergent Change(发散式变化)

- 希望软件容易被修改，并且希望修改只影响某一点，只在此处修改，做不到就出问题了。
- 多个变化都会引发变动可以尝试拆类 隔离变化

## 3.6 Shotgun Surgery(霰弹式修改)

Shotgun Surgery类似Divergent Change但恰恰相反。没遇到某个变化需要在许多类做修改，要修改的代码分散四处。

- 使用Move Method(142)和Move Field(146) 把需要修改的代码放进同一个类，没有合适类安置就是运用Inline Class(154)相关行为放进同一个类
- Divergent Change 一个类受到多变化影响
- Shotgun Surgery一种变化引发多个类相应修改

## 3.7 Feature Envy(依恋情结)

- 问题：某个函数依赖的数据几乎都来源于另一个类
- 方案：采用Move Method(142)把它移动到它该去的地方。
  - 可以先extract 再 move
  - 函数和数据最多的类在一起
- 复杂模式的破坏
  - Strategy 和 Visitor
  - 将变化的放在一起 便于修改函数行为 strategy 可以在context随意替换strategy实现不同行为
  - visitor 产生的元素可以随意变化，同时处理函数的方法可以变化
- 

## 3.8 Data Clumps(数据泥团)

- 某些数据总是一起出现，使用Extract Class
- 注意函数签名采用 Introduce Patameter Object和Preserve Whole Object减肥
- 合适减少数据项 并且考虑能否抽取

## 3.9 Primitive Obsession(基本类型偏执)

- 结构类型打破基本类型的积木块
- 小任务运用小对象例如结合数值和币种的Money类
- 运用Replace Data Value with Object(175)将数值替换为对象
- 类型码可以Replace Type Code with Class替换
- 条件表达式可运用 Replace Type Code with Subclass / Replace TypeCode with State/Strategy 处理
- 从数组挑选数据可运用Replace Array with Object

## 3.10 Switch Statements(switch惊悚现身)

面向对象=》少用switch

- 本质上switch是重复
- 方案
  - extract method 将switch 语句提炼到一个独立函数
  - move method 放到多态类
  - 判断是否使用Replace Type Code with Subclasses 或Replace Type Code with State/Strategy
  - 完成集成运用Replace Conditional with Polymorphism(255)
  - 单一函数选择Replace Parameter with Explicit Methods(285)
  - null考虑Introduce Null Object(260)

## 3.11 Parallel Inheritance Hierarchies(平行继承体系)

shotgun Surgery特殊情况 同时需要增加多个子类，move field/method

## 3.12 Lazy Class(冗赘类)

- 类没有价值就该消失
- 使用Collapse Hierarchy(344) 没用组件采用Inline Class(154)

## 3.13 Speculative Generality(夸夸其谈未来性)

- 想着将来要做的并企图用各种各样钩子和特殊情况处理非必要
- 抽象类没太大作用就运用collapse Hierarchy(344)
- 不必要委托用Inline Class
- 参数没用到运用 Remove Parameter(277) 函数名称多余的抽象 Rename Method(273)

## 3.14 Temporary Field(令人迷惑的暂时字段)

- 类内某些变量只为特定情况设置
- 收集并放到一个合适的类内

## 3.15 Message Chains(过度耦合的消息链)

- 调用链路过长
- 采用HIDE Delegate
- 把一系列对象编程middle man
- 方案
  - 观察消息链的最终对象干什么
  - 对象代码提炼到独立函数
  - move method推入消息链
- 

## 3.16 Middle Man(中间人)

- 对象=》封装 隐藏细节
- 若一个类内一半函数都委托给其他类，尝试干掉这些中间类Remove Middle Man(160)运用Inline Method(117)放进调用端
- 

## 3.17 Inappropriate Intimacy(不适当亲密)

- 类互相探究 必须拆散，采用move method/field 划清界限
- 也可尝试change bidirectional association to Unidirectional(双线关联变单向200) 让其中一个类断绝关系

## 3.18 Alternative Classes with Different Interfaces(异曲同工的类)

两个函数做同一件事函数签名不同 反复运用move method

## 3.19 Incomplete Library Class(不完美类库)

对象的终极目的=》复用

- 想修改一两个函数运用Introduce Foreigion Method(162)
- 添加一大堆额外行为运用Introduce Local Extension(164)

## 3.20 Data Class(纯粹的数据类)

- 只有字段+访问
- 运用Encapsulate field(206)封装他们
- 容器字段也封装encapsulate collection(208)
- 不该被其他类修改的remove setting method(300)
- 找到data class运用点将方法移动到data class
- data class 应该承担一些责任

## 3.21 Refuse Bequest（被拒绝的遗赠）

- 所有超累都是抽象
- 拒绝实现采用replace inheritance with delegation（352）来达到目的

## 3.22 Comments（过多注释）

- 注释不是除臭剂
- 注释不应该因为代码很糟糕而写
- 运用重构去掉不必要注释
- 许要写注释优先考虑重构